
* Make up a pretty logo.

* Doxygen suppport.

* Create software style guide for toolchain users, and then refactor the existing HAL libraries to make sure they comply with the style guide.

* Optimize the HAL; at the moment it takes up way too much space.  Optimizing the implementations may help, but it is also possible that some redesign may be required to some bits.

* Get the AVR32 bootloader working.

* Create a USART module for the AVR bootloader.  Thus check that the bootloader is working properly on the ATmega2560.

* Complete interfaces for SPI, I2C; this just requires a check that everything is ok.

* Implement SPI and I2C libraries for Atmega2560.

* Complete HAL interface design for remaining peripherals.

* Complete HAL implementation for remaining peripherals and targets.

* Complete bootloader implementation for remaining peripherals and targets.

* Add support for flashing both bootloader and application code direct from a PC via ISP (via a known ISP programmer with existing drivers).

* Add support for flashing bare metal and RTOS application code direct from a PC via USART (via serial cable) or CAN (via CAN-USB dongle) to devices which already have the appropriate bootloader.

* Add support for compiling and ISP flashing bare metal applications direct from a PC via ISP (via a known ISP programmer with existing drivers).  The difference from the bootloader case is that the application code may need to be placed into a different part of memory, and there are fuse bits to be set to switch between application code and bootloader code booting.  The principles behind VF will mean that this should never be used in practise, but being able to do it is useful for the sake of completeness, and because it will ensure that we actually know what we are doing (thus ensuring that the other use cases, which ARE important, are also being done properly).

* Add support for multiple 'tasks' on Linux based platforms.

* Add support for components having source code split into subfolders.

* Add python bindings for Linux platforms and toolchain support for python files (since python files are interpreted, all that one needs to do is copy the source files over into the output folder, so that they can get included in the file system image).

* Create software for uploading firmware from Linux platforms to RTOS/bare-metal platforms.

* Add FreeRTOS support for remaining targets, and actually test that FreeRTOS works as it is supposed to work.

* Configure support for inclusion of vendor code via Git submodules.

* Add support for MAVlink communications via shared messaging, including code generation.

* Add the ATmega328 to the targets list.  Actually, I think I mean the ATmega328, but maybe I don't: I mean whatever the MUX/PPM controller on the ArduPilot Mega is; look this up.  Actually, possibly belay that: the new Arduino's and hence the APMv2 might have a different MCU as the USB interface (and hence the MUX/PPM controller), in which case THAT should be added to the target list instead.

* res/arm should probably be renamed to res/omap, since different ARM processors have quite different peripherals, so 'arm' is not really sufficiently specific.  There are quite a few places this path will need to be updated though?  Actually, maybe omap4, since there might also be a need for an omap3 (or even omap5 folder as well), or maybe they should be subfolders, so res/omap/omap4. 

* Add compatibility with existing Arduino compatible projects such as the APM (plus any other libraries the APM depends on).  Need to have a build configuration which disables the HAL, and instead uses the existing Arduino libraries, which I guess can be in lib somewhere?  Also, need to add support for whatever other extensions the Arduino wants to use.  Also, Arduino projects probably support source in nested folders, which we don't support at the moment?

* The interface for mem.h has a bunch of functions which take a pointer to the array of data to be written.  Since we are using C++, these should be changed to instead take a REFERENCE to the array of data to be written.  Similarly for anywhere else where this applies.

* Maybe should split the preprocess script up into different files?

* Add support for STM32 targets.  Only bare metal, can use the 'Summon ARM Toolchain'.

* Add support for Gumstix targets (specifically, the OMAP3530 I think).

* The doc folder should have 'targets' and 'platforms', subfolders containing user documentation for each of those things.  For instance, the ATmega2560 folder should at least contain the Atmel User Guide for the MCU.

* The user guide and maintenance guide should be split up into different files, rather than being one monolithic TeX file.

* When the user selects the 'reconfigure component' option, then the existing configuration values should be shown or something; at the moment this is a bit of an issue because if someone wants to change one configuration setting, they need to know what all the other values should be set to, which may be an unlikely situation in multi-user development.

* The all important 'Test Scaffold': Dummy implementations of the HAL (and other things) so that one can compile the embedded software on a desktop computer to test the software without access to the hardware proper.  Probably then there should be a flag to pass to the build script ('-s' or '--scaffold' or similar) which results in the selected components being build for operation on the desktop instead of the actual target.  This could get somewhat complicated considering the cases for testing components intended for use on RTOS or Linux platforms?

* Support for continuous integration stuff.  This is two-fold: firstly, the toolchain itself should have some kind of support for continuous integration testing systems (for example, to support the CI HITL simulation testing we want to have the autopilot code doing); and secondly, the actual development of the toolchain needs to be under continuous integration, so that changes to the implementations of the HAL etc are tested for compatibility.

* Implement print_info_toolchain so that it is able to detect which version of the toolchain this is, etc.

* Implement print_info_component so that it basically prints the contents of the component configuration file, but nicely formatted.

* Split C and C++ header files, such that C++ header files have an .HPP extension to match the corresponding C++ file's .CPP extension.  Mostly this entails making changse to the template files, fixing up the scripts to use the new files appropriately, and making sure that the build scripts and make files include the new .HPP extension as appropriate.
