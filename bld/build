#!/bin/bash

###########################################################################################################################
###															###
### Name:		build												###
###															###
### Author:		Zac Frank											###
###															###
### Date Created:	17-11-2011											###
###															###
### Type:		Bash Script											###
###															###
### Purpose:		This script builds the components being developed with the toolchain, calling make with certain ###
###			parameters depending on the active component and its specifications (target, platform, etc.) 	###
###															###
###########################################################################################################################

# FIGURE OUT WHERE WE ARE.

# Determine what the absolute path to the root of the toolchain is.
SCRIPT=`readlink -f $0`
SCRIPTPATH=`dirname $SCRIPT`
TCPATH=$(echo $SCRIPTPATH | sed 's/\/bld.*//')

# DEFINE CONSTANTS.

# Define file names.

USER_CONFIG_FILE="var/config.cfg"
BUILD_CONFIG_FILE="bld/build_configs.cfg"
TMP_SRC_DIR="tmp/tmp_src"
OUTPUT_DIR="bin"

# Define the colours used for interface output.
source $TCPATH/bld/common/def_colours

# Define the functions used for preprocessing.
source $TCPATH/bld/preprocess/preprocess

######################################## FUNCTION #########################################
###											###
### Name:		makeavr								###
###											###
### Inputs/Outputs:	None								###
###											###
### Purpose:		Copies AVR makefile into tmp directory, edits it, and uses it 	###
### 			to compile the files that are already there.		     	###
###											###
###########################################################################################

makeavr() 
{ 
	# Copy the relevant makefile in with the source.
	echo -e "${CYAN}Constructing makefile for component $COMPONENT...\n${NO_COLOUR}"
	cp $MAKEFILE $TCPATH/$TMP_SRC_DIR/$COMPONENT

	# Get the list of names of source and header files.
	C_FILES=$(ls $TCPATH/$TMP_SRC_DIR/$COMPONENT/*.c 2>/dev/null | sed ':a;N;$!ba;s/\n/ /g')
	H_FILES=$(ls $TCPATH/$TMP_SRC_DIR/$COMPONENT/*.h 2>/dev/null | sed ':a;N;$!ba;s/\n/ /g')
	S_FILES=$(ls $TCPATH/$TMP_SRC_DIR/$COMPONENT/*.s 2>/dev/null | sed ':a;N;$!ba;s/\n/ /g')
								
	# Update the working makefile with the appropriate values for this component.	
	sed -i "s^\(MCU *= *\).*^\1$MCU_CODE^" $TCPATH/$TMP_SRC_DIR/$COMPONENT/Makefile	# NOTE - Using '^' as delimiters.
	sed -i "s^\(CC *= *\).*^\1$COMPILER^" $TCPATH/$TMP_SRC_DIR/$COMPONENT/Makefile	
	sed -i "s^\(PRJSRC *= *\).*^\1$C_FILES^" $TCPATH/$TMP_SRC_DIR/$COMPONENT/Makefile
	sed -i "s/\(PROJECTNAME *= *\).*/\1$COMPONENT/" $TCPATH/$TMP_SRC_DIR/$COMPONENT/Makefile
    
	# Actually make the component.
	echo -e "${CYAN}Making component $COMPONENT ...\n${NO_COLOUR}"
	make -C $TCPATH/$TMP_SRC_DIR/$COMPONENT all			

	# NOTE - Don't put anything in here; we need the return value from 'make' below.

	# Check the return value from make, to determine if an error occurred during compilation.
	if [ $? != 0 ]; then
		# Something went wrong.
		echo -e "\n${RED}Compilation error.  Failed to build component $COMPONENT.\n${NO_COLOUR}"
		return 1
	fi
	
	# The compilation worked, so now just copy across the output binaries.
	$OBJCOPY -O ihex $TCPATH/$TMP_SRC_DIR/$COMPONENT/$COMPONENT.out $TCPATH/$OUTPUT_DIR/$COMPONENT.hex

	# Check the return value from the object copy.
	if [ $? != 0 ]; then
		# Something went wrong.
		echo -e "\n${RED}Object copy error.  Failed to build component $COMPONENT.\n${NO_COLOUR}"			
		return 1
	fi									

	# All done.
	echo -e "\n${BOLD_WHITE}Build successful.  Output binary written to $OUTPUT_DIR/$COMPONENT.hex.\n${NO_COLOUR}"
	return 0
}

######################################## FUNCTION #########################################
###											###
### Name:		makeavr_bootloader						###
###											###
### Inputs/Outputs:	None								###
###											###
### Purpose:		Builds the AVR bootloader for the current component.	     	###
###											###
###########################################################################################

makeavr_bootloader() 
{
	# Make sure there aren't any old files in the spot we are about to put new files.
	rm -rf $TCPATH/$TMP_SRC_DIR/${COMPONENT}_bootloader
	mkdir -p $TCPATH/$TMP_SRC_DIR/${COMPONENT}_bootloader

	# Copy all the source files into the tmp directory, where the actual making will occur.
	cp $SOURCEPATH/*.c $SOURCEPATH/*.h $TCPATH/$TMP_SRC_DIR/${COMPONENT}_bootloader 2>/dev/null

	# Preprocess the copied header files.
	FILES=$TCPATH/$TMP_SRC_DIR/${COMPONENT}_bootloader/*.h
	for FILE in $FILES; do
		# Preprocess this header file.
		preprocess_bootloader $FILE
	done

	# Preprocess the copied source files.
	FILES=$TCPATH/$TMP_SRC_DIR/${COMPONENT}_bootloader/*.c
	for FILE in $FILES; do
		# Preprocess this source file.
		preprocess_bootloader $FILE
	done

	# Copy the relevant makefile in with the source.
	echo -e "${CYAN}Constructing makefile for component $COMPONENT bootloader...\n${NO_COLOUR}"
	cp $MAKEFILE $TCPATH/$TMP_SRC_DIR/${COMPONENT}_bootloader/Makefile

	# Get the list of names of source files.
	C_FILES=$(ls $TCPATH/$TMP_SRC_DIR/${COMPONENT}_bootloader/*.c | sed ':a;N;$!ba;s/\n/ /g')
								
	# Update the working makefile with the appropriate values for this component.	
	sed -i "s^\(MCU *= *\).*^\1$MCU_CODE^" $TCPATH/$TMP_SRC_DIR/${COMPONENT}_bootloader/Makefile	# NOTE - Using '^' as delimiters.
	sed -i "s^\(CC *= *\).*^\1$COMPILER^" $TCPATH/$TMP_SRC_DIR/${COMPONENT}_bootloader/Makefile	
	sed -i "s^\(PRJSRC *= *\).*^\1$C_FILES^" $TCPATH/$TMP_SRC_DIR/${COMPONENT}_bootloader/Makefile
	sed -i "s/\(PROJECTNAME *= *\).*/\1${COMPONENT}_bootloader/" $TCPATH/$TMP_SRC_DIR/${COMPONENT}_bootloader/Makefile
	sed -i "s/\(BOOTSTART *= *\).*/\1$BOOTSTART/" $TCPATH/$TMP_SRC_DIR/${COMPONENT}_bootloader/Makefile	
    
	# Actually make the component.
	echo -e "${CYAN}Making bootloader for component $COMPONENT ...\n${NO_COLOUR}"
	make -C $TCPATH/$TMP_SRC_DIR/${COMPONENT}_bootloader all			

	# NOTE - Don't put anything in here; we need the return value from 'make' below.

	# Check the return value from make, to determine if an error occurred during compilation.
	if [ $? != 0 ]; then
		# Something went wrong.
		echo -e "\n${RED}Compilation error.  Failed to build bootloader for component $COMPONENT.\n${NO_COLOUR}"
		return 1
	fi
	
	# The compilation worked, so now just copy across the output binaries.
	$OBJCOPY -O ihex $TCPATH/$TMP_SRC_DIR/${COMPONENT}_bootloader/${COMPONENT}_bootloader.out $TCPATH/$OUTPUT_DIR/${COMPONENT}_bootloader.hex

	# Check the return value from the object copy.
	if [ $? != 0 ]; then
		# Something went wrong.
		echo -e "\n${RED}Object copy error.  Failed to build bootloader for component $COMPONENT.\n${NO_COLOUR}"			
		return 1
	fi									

	# All done.
	echo -e "\n${BOLD_WHITE}Build successful.  Output binary written to $OUTPUT_DIR/${COMPONENT}_bootloader.hex.\n${NO_COLOUR}"
	return 0
}

######################################## FUNCTION #########################################
###											###
### Name:		makeavr32							###
###											###
### Inputs/Outputs:	None								###
###											###
### Purpose:		Copies AVR32 makefile into tmp directory, edits it, and uses it	###
### 			to compile the files that are already there.		     	###
###											###
###########################################################################################

makeavr32()
{
	# Check if the AVR32 compiler has been uncompressed already.
	inflate_avr32cc

	# Copy the relevant makefile in with the source.
	echo -e "${CYAN}Constructing makefile for component $COMPONENT...\n${NO_COLOUR}"
	cp $MAKEFILE $TCPATH/$TMP_SRC_DIR/$COMPONENT

	# Get the list of names of source and header files.
	C_FILES=$(ls $TCPATH/$TMP_SRC_DIR/$COMPONENT/*.c 2>/dev/null | sed ':a;N;$!ba;s/\n/ /g')
	H_FILES=$(ls $TCPATH/$TMP_SRC_DIR/$COMPONENT/*.h 2>/dev/null | sed ':a;N;$!ba;s/\n/ /g')
	S_FILES=$(ls $TCPATH/$TMP_SRC_DIR/$COMPONENT/*.s 2>/dev/null | sed ':a;N;$!ba;s/\n/ /g')
								
	# Update the working makefile with the appropriate values for this component.	
	sed -i "s^\(PART *= *\).*^\1$MCU_CODE^" $TCPATH/$TMP_SRC_DIR/$COMPONENT/Makefile	# NOTE - Using '^' as delimiters.
	sed -i "s^\(CC *= *\).*^\1$COMPILER^" $TCPATH/$TMP_SRC_DIR/$COMPONENT/Makefile	
	sed -i "s^\(PRJSRC *= *\).*^\1$C_FILES^" $TCPATH/$TMP_SRC_DIR/$COMPONENT/Makefile
	sed -i "s^\(HEADERS *= *\).*^\1$H_FILES^" $TCPATH/$TMP_SRC_DIR/$COMPONENT/Makefile
	sed -i "s^\(TARGET *= *\).*^\1$COMPONENT^" $TCPATH/$TMP_SRC_DIR/$COMPONENT/Makefile
    
	# Actually make the component.
	echo -e "${CYAN}Making component $COMPONENT ...\n${NO_COLOUR}"
	make -C $TCPATH/$TMP_SRC_DIR/$COMPONENT all			

	# NOTE - Don't put anything in here; we need the return value from 'make' below.

	# Check the return value from make, to determine if an error occurred during compilation.
	if [ $? != 0 ]; then
		# Something went wrong.
		echo -e "\n${RED}Compilation error.  Failed to build component $COMPONENT.\n${NO_COLOUR}"
		return 1
	fi
	
	# The compilation worked, so now just copy across the output binaries.
	$OBJCOPY -O ihex $TCPATH/$TMP_SRC_DIR/$COMPONENT/$COMPONENT.elf $TCPATH/$OUTPUT_DIR/$COMPONENT.hex

	# Check the return value from the object copy.
	if [ $? != 0 ]; then
		# Something went wrong.
		echo -e "\n${RED}Object copy error.  Failed to build component $COMPONENT.\n${NO_COLOUR}"			
		return 1
	fi									

	# All done.
	echo -e "\n${BOLD_WHITE}Build successful.  Output binary written to $OUTPUT_DIR/$COMPONENT.hex.\n${NO_COLOUR}"
	return 0
}

######################################## FUNCTION #########################################
###											###
### Name:		makearm								###
###											###
### Inputs/Outputs:	None								###
###											###
### Purpose:		Copies ARM makefile into tmp directory, edits it, and uses it	###
### 			to compile the files that are already there.		     	###
###											###
###########################################################################################

makearm()
{
	# Copy the relevant makefile in with the source.
	echo -e "${CYAN}Constructing makefile for component $COMPONENT...\n${NO_COLOUR}"
	cp $MAKEFILE $TCPATH/$TMP_SRC_DIR/$COMPONENT

	# If we are using a linker script, then add the appropriate linker flags to use it.
	if [ ! -z $LINKSCRIPT ] && [ -r $LINKSCRIPT ]; then
		# Copy the relevant linker script in with the source.
		cp $LINKSCRIPT $TCPATH/$TMP_SRC_DIR/$COMPONENT/linker_script.ld

		# A linker script is specified, so set the linker flags to refer to it.
		$LFLAGS="-T linker_script.ld $LFLAGS"
	fi

	# Get the list of names of source and header files.
	C_FILES=$(ls $TCPATH/$TMP_SRC_DIR/$COMPONENT/*.c 2>/dev/null | sed ':a;N;$!ba;s/\n/ /g')
	H_FILES=$(ls $TCPATH/$TMP_SRC_DIR/$COMPONENT/*.h 2>/dev/null | sed ':a;N;$!ba;s/\n/ /g')
	S_FILES=$(ls $TCPATH/$TMP_SRC_DIR/$COMPONENT/*.s 2>/dev/null | sed ':a;N;$!ba;s/\n/ /g')
								
	# Update the working makefile with the appropriate values for this component.	
	sed -i "s^\(MCPU *= *\)BUILD_INSERTS_MCU_CODE_HERE^\1$MCU_CODE^" $TCPATH/$TMP_SRC_DIR/$COMPONENT/Makefile	# NOTE - Using '^' as delimiters.
	sed -i "s^\(CC *= *\)BUILD_INSERTS_COMPILER_HERE^\1$COMPILER^" $TCPATH/$TMP_SRC_DIR/$COMPONENT/Makefile	
	sed -i "s^\(AS *= *\)BUILD_INSERTS_ASSEMBLER_HERE^\1$ASSEMBLER^" $TCPATH/$TMP_SRC_DIR/$COMPONENT/Makefile
	sed -i "s^\(LD *= *\)BUILD_INSERTS_LINKER_HERE^\1$LINKER^" $TCPATH/$TMP_SRC_DIR/$COMPONENT/Makefile
	sed -i "s^\(CFLAGS *= *.* *\)BUILD_INSERTS_CFLAGS_HERE^\1$CFLAGS^" $TCPATH/$TMP_SRC_DIR/$COMPONENT/Makefile
	sed -i "s^\(AFLAGS *= *.* *\)BUILD_INSERTS_AFLAGS_HERE^\1$AFLAGS^" $TCPATH/$TMP_SRC_DIR/$COMPONENT/Makefile
	sed -i "s^\(LFLAGS *= *.* *\)BUILD_INSERTS_LFLAGS_HERE^\1$LFLAGS^" $TCPATH/$TMP_SRC_DIR/$COMPONENT/Makefile
	sed -i "s^\(SRC_C *= *\).*^\1$C_FILES^" $TCPATH/$TMP_SRC_DIR/$COMPONENT/Makefile
	sed -i "s^\(SRC_H *= *\).*^\1$H_FILES^" $TCPATH/$TMP_SRC_DIR/$COMPONENT/Makefile
	sed -i "s^\(SRC_S *= *\).*^\1$S_FILES^" $TCPATH/$TMP_SRC_DIR/$COMPONENT/Makefile
	sed -i "s^\(TARGET *= *\).*^\1$TCPATH/$TMP_SRC_DIR/$COMPONENT/$COMPONENT^" $TCPATH/$TMP_SRC_DIR/$COMPONENT/Makefile
    
	# Actually make the component.
	echo -e "${CYAN}Making component $COMPONENT ...\n${NO_COLOUR}"
	make -C $TCPATH/$TMP_SRC_DIR/$COMPONENT all			

	# NOTE - Don't put anything in here; we need the return value from 'make' below.

	# Check the return value from make, to determine if an error occurred during compilation.
	if [ $? != 0 ]; then
		# Something went wrong.
		echo -e "\n${RED}Compilation error.  Failed to build component $COMPONENT.\n${NO_COLOUR}"
		return 1
	fi
	
	# The compilation worked, so now just copy across the output binaries into the appropriate format.
	$OBJCOPY -O $OUTPUT_TYPE $TCPATH/$TMP_SRC_DIR/$COMPONENT/$COMPONENT $TCPATH/$OUTPUT_DIR/$OUTPUT_NAME

	# Check the return value from the object copy.
	if [ $? != 0 ]; then
		# Something went wrong.
		echo -e "\n${RED}Object copy error.  Failed to build component $COMPONENT.\n${NO_COLOUR}"			
		return 1
	fi									

	# All done.
	echo -e "\n${BOLD_WHITE}Build successful.  Output binary written to $OUTPUT_DIR/$OUTPUT_NAME.\n${NO_COLOUR}"
	return 0
}

##################################### MINOR FUNCTIONS ####################################

# Uncompress the AVR32 compiler if required, since it is stored in compressed form.
inflate_avr32cc()
{
	# Check if the AVR32 compiler has been uncompressed already.
	if [ ! -d $TCPATH/res/avr32/avr32comp ]; then
		# We need to uncompress the compiler before we continue.		
		echo -e "${CYAN}Uncompressing the AVR32 compiler and libraries...\n${NO_COLOUR}"
		tar -C $TCPATH/res/avr32 -xf  $TCPATH/res/avr32/avr32comp.tar
    	fi

	# All done.
	return
}

# Print a usage message.
usage()
{
	# Block-concatenate the message.
	cat << EOF

Usage: $0 [Options] [Component Names]

This script is used, as part of the 'Valley Forge' Embedded Toolchain to build components.

Parameters:

	[Component Names]		Space separated list of the components to build, or "all".

Options:
	-h --help			Show this message.
	-a --all			Build all components.
	-r --retain			Retain temporary files at completion of script.
	-l --loader			Build the bootloader for each component as well.
	-n --name <Component Name>	Specify the name of a component to build.
EOF
	# All done.
	return
}

################################ SCRIPT PROPER STARTS HERE ###############################

# Delete everything in the tmp directory.
rm -rf  $TCPATH/tmp/*

# PARSE ANY COMMAND LINE PARAMETERS.

# Indicate where we are up to in the script.
echo -e "${BOLD_CYAN}\nParsing command line parameters...\n${NO_COLOUR}"

# Reset fields to be extracted from the parameters.
NAME=
RETAIN=
ALL=
LOADER=

# Define variables required for 'getopt' to work.
PROGNAME=${0##*/} 
SHORTOPTS="harlcn:"
LONGOPTS="help,all,retain,loader,clean,name:"

# Use 'getopt' to parse the command line options.
ARGS=$(getopt -s bash --options $SHORTOPTS --longoptions $LONGOPTS --name $PROGNAME -- "$@")
eval set -- "$ARGS"

# Handle the parsed parameters.
while true; do
	# Select the appropriate behaviour for each parameter.
	case $1 in
		-h|--help)
			# Just print the usage message and then exit.
			usage
			exit 0
			;;
		-a|--all)
			# Select 'building all components'.
			ALL=1
			;;
		-r|--retain)
			# Select 'retaining temporary files'.
			RETAIN=1
			;;
		-l|--loader)
			# Select 'creating bootloaders'.
			LOADER=1
			;;
		-c|--clean)
			# Remind the user that there is no 'clean' option here.
			echo -e "${RED}\nThis script automatically cleans temporary files upon completion.\n" 
			echo -e "To retain files built during compilation, type ./build retain\n${NO_COLOUR}"
			exit 0		
			;;
		-n|--name)
			# Specify the name of the component to build.
			shift
			NAME="$NAME$1 " # NOTE - The space in intentional!
			;;
		--)
			# We're done parsing options.  Anything else must be parameters.
			shift
			NAME="$NAME$* " # NOTE - The space in intentional!
			break
			;;
		*)
			# Anything else must be parameters.
			shift
			NAME="$NAME$* " # NOTE - The space in intentional!
			break
			;;
	esac

	# Advance on to the next parameter.
	shift
done

# If the provided name was 'all', then set the ALL variable even if the '-a' option wasn't given.
if [ "$NAME" == "all " ]; then  # NOTE - The space in intentional!
	ALL=1
fi

# If there was no component name specified, we'll just try to build the 'active component' instead.
if [ "$NAME" == " " ] && ! [ $ALL ]; then  # NOTE - The space in intentional!
	# Try to build the 'active component' instead.

	# Check to make sure the user configuration file is there.
	if [ ! -r $TCPATH/$USER_CONFIG_FILE ]; then
		# The configuration file is missing, so we don't know what to compile.
		echo -e "${BOLD_RED}FATAL - User configuration file ($USER_CONFIG_FILE) was not found.\n${NO_COLOUR}"
		exit 1
	fi

	# Extract the value of the 'active component' from the user configuration file.
	CURR=$(grep -v "#" $TCPATH/$USER_CONFIG_FILE | grep tc_curr | cut -d '=' -f 2)

	# Check if the toolchain has an 'active component' to build.
	if [ "$CURR" == "none" ] || [ -z "$CURR" ]; then
		# Tell the user there is nothing to compile, then exit.
		echo -e "${RED}No active component is set; nothing to build.\n${NO_COLOUR}"
		exit 0
	else
		# Schedule the 'active component' to be built.
		NAME=$CURR
	fi
fi

# If we're going to build 'everything', then get a list of what 'everything' actually entails.
if [ $ALL ]; then
	# Get a list of all the components in the src folder.
	NAME=$(ls -C $TCPATH/src)
fi

# BUILD THE COMPONENTS ONE BY ONE.

# Parse the build configurations file.
source $TCPATH/bld/common/load_build_configs

# NOTE - Since each component is independent of one another, the order they are built in doesn't matter.

# Iterate through each of the components in the queue.
for COMPONENT in $NAME
do
	# First, check if this component actually exists.
	if [ ! -d "$TCPATH/src/$COMPONENT" ]; then
		# The component does't have a matching source folder, so skip it and move on.
		echo -e "${RED}No source folder found.  Skipping component $COMPONENT.\n${NO_COLOUR}"
		continue
	fi

	# Indicate we are starting the build process for this component.
	echo -e "${BOLD_CYAN}Building component $COMPONENT...\n${NO_COLOUR}"

	# First, we need to read the configuration information for this component.
	echo -e "${CYAN}Loading component build configuration...\n${NO_COLOUR}"

	# Reset any variables which may have been set by the previous component.
	TARGET=
	PLATFORM=
	BOOTLOADER=

	# Check if we can find the config file for this component.
	if ! [ -r "$TCPATH/src/$COMPONENT/$COMPONENT.cfg" ]; then
		# The configuration file isn't there.  Ask the user if they want to create the file, or skip this component.
		echo -e "${RED}No configuration file found for component $COMPONENT.\n${NO_COLOUR}"
		echo -e -n "${GREEN}Do you wish to create the missing configuration file now? (Y/N) ${NO_COLOUR}"
		read -n 1
		echo -e "\n" # NOTE - This is because the read command won't put a newline after it reads a character.
		
		# If they responded YES, then rebuild the configuration file.  If NO, then skip this component.
		if [[ $REPLY =~ ^[Yy]$ ]]; then
			# Rebuild the configuration file.
			
			# Call the 'component_create' script: it will handle rebuilding the configuration file.
			bash $TCPATH/bld/create/create_component -c $COMPONENT

			# TODO - Need to check that this actually worked.  If it didn't, then we need to bail.
		else
			# Just skip this component and move on.
			echo -e "${YELLOW}No configuration file.  Skipping component $COMPONENT.\n${NO_COLOUR}"
			continue
		fi
	fi

	# Extract relevant configuration information from the configuration file.
	TARGET=$(grep -v "#" $TCPATH/src/$COMPONENT/$COMPONENT.cfg | grep "^TARGET" | cut -d '=' -f 2)
	PLATFORM=$(grep -v "#" $TCPATH/src/$COMPONENT/$COMPONENT.cfg | grep "^PLATFORM" | cut -d '=' -f 2)
	BOOTLOADER=$(grep -v "#" $TCPATH/src/$COMPONENT/$COMPONENT.cfg | grep "^BOOTLOADER" | cut -d '=' -f 2)

	# Reset any variables which may have been set by the previous component.
	BCONF_NAME=
	COMPILER=
	ASSEMBLER=
	OBJCOPY=
	MAKEFUNCTION=
	MAKEFILE=
	LINKSCRIPT=
	MCU_CODE=
	IOHEADER=
	CFLAGS=
	AFLAGS=
	LFLAGS=
	OUTPUT_TYPE=
	OUTPUT_NAME=

	# Check to see if we can find a matching build configuration.
	BCONF="bconf_${TARGET}_${PLATFORM}"
	if [ `declare -f | grep "$BCONF ()" | wc -l` == 0 ]; then
		# No matching build configuration was found, so skip this component and move on.
		echo -e "${RED}No suitable build configuration found.  Skipping component $COMPONENT.\n${NO_COLOUR}"
		continue
	else
		# There is a matching build configuration, so load it.
		echo -e "${CYAN}Loading build configuration ($BCONF)...\n${NO_COLOUR}"
		$BCONF

		# Check that all the required variables were set by the build configuration.
		if [ -z "$BCONF_NAME" ] || [ -z "$MAKEFUNCTION" ] || [ -z "$MAKEFILE" ]; then
			# At least one of the required variables was not set, so skip this component and move on.
			echo -e "${RED}Build configuration incomplete.  Skipping component $COMPONENT.\n${NO_COLOUR}"
			continue
		fi
	
		# Check that the make function specified by the build configuration actually exists.
		if [ `declare -f | grep "$MAKEFUNCTION" | wc -l` == 0 ]; then
			# The specified make function doesn't exist, so skip this component and move on.
			echo -e "${RED}Build configuration specifies an invalid make function.  Skipping component $COMPONENT.\n${NO_COLOUR}"
			continue
		fi

		# The build configuration was loaded successfully.
		echo -e "${CYAN}Loaded build configuration '$BCONF_NAME'.\n${NO_COLOUR}"
	fi

	# TODO - If there is anything required to set up the platform, maybe it goes about here?
	
	# Now, we compile the application code.
	echo -e "${CYAN}Compiling application code...\n${NO_COLOUR}"

	# Count the number of C files in the source folder for this component.
	C_COUNT=`ls -l $TCPATH/src/$COMPONENT/*.c 2>/dev/null | wc -l`
	echo -e "${CYAN}Found $COUNT C source files.\n${NO_COLOUR}"

	# Count the number of S files in the source folder for this component.
	S_COUNT=`ls -l $TCPATH/src/$COMPONENT/*.s 2>/dev/null | wc -l`
	echo -e "${CYAN}Found $COUNT assembler source files.\n${NO_COLOUR}"

	# If there are no C source files and no assembler source files, then there is nothing to do.
	if [ ! $C_COUNT ] && [ ! $S_COUNT ]; then
		# There are no C source files, so skip this component and move on.
		echo -e "${YELLOW}No source files present in source folder.  Skipping component $COMPONENT\n${NO_COLOUR}"
		continue
	fi

	# Make sure there aren't any old files in the spot we are about to put new files.
	rm -rf $TCPATH/$TMP_SRC_DIR/$COMPONENT
	mkdir -p $TCPATH/$TMP_SRC_DIR/$COMPONENT

	# Copy all the source files into the tmp directory, where the actual making will occur.
	cp $TCPATH/src/$COMPONENT/*.c $TCPATH/src/$COMPONENT/*.h $TCPATH/src/$COMPONENT/*.s $TCPATH/$TMP_SRC_DIR/$COMPONENT 2>/dev/null

	# Preprocess the copied header files.
	shopt -s nullglob
	for FILE in $TCPATH/$TMP_SRC_DIR/$COMPONENT/*.h; do
		# Preprocess this header file.
		preprocess_general $FILE
	done
	shopt -u nullglob

	# Preprocess the copied source files.
	shopt -s nullglob
	for FILE in $TCPATH/$TMP_SRC_DIR/$COMPONENT/*.c; do
		# Preprocess this source file.
		preprocess_general $FILE
	done
	shopt -u nullglob

	# Preprocess the copied assembler files.
	shopt -s nullglob
	for FILE in $TCPATH/$TMP_SRC_DIR/$COMPONENT/*.s; do
		# Preprocess this source file.
		preprocess_general $FILE
	done
	shopt -u nullglob

	# Actually run the appropriate make function for this build configuration.
	$MAKEFUNCTION

	# Check if the make function worked.  If not, we don't go any further with this component.
	if [ $? != 0 ]; then
		# We just skip the booloader and anything else, and move on.
		echo -e "${YELLOW}Application code build failed.  Skipping additional build stages...\n${NO_COLOUR}"
		continue
	fi

	# Check if we should also make the corresponding bootloader for this component.
	if [ $LOADER ]; then
		# We need to make the corresponding bootloader as well.

		# Now, we build the application code for the component.
		echo -e "${CYAN}Building bootloader for component ${COMPONENT}...\n${NO_COLOUR}"
		
		# First, we need to read the configuration information for this component.
		echo -e "${CYAN}Loading bootloader configuration...\n${NO_COLOUR}"

		# Reset any variables which may have been set by the previous bootloader.
		BLOAD_NAME=
		COMPILER=
		OBJCOPY=
		MAKEFUNCTION=
		MAKEFILE=
		SOURCEPATH=
		MCU_CODE=
		IOHEADER=
		BOOTSTART=

		# Check to see if we can find a matching bootloader configuration.
		BLOADCONF="bload_${TARGET}_${BOOTLOADER}"
		if [ `declare -f | grep "$BLOADCONF ()" | wc -l` == 0 ]; then
			# No matching bootloader configuration was found, so skip this and move on.
			echo -e "${RED}No suitable bootloader configuration found.  Skipping bootloader for component $COMPONENT.\n${NO_COLOUR}"
			continue
		else
			# There is a matching bootloader configuration, so load it.
			echo -e "${CYAN}Loading bootloader configuration ($BLOADCONF)...\n${NO_COLOUR}"
			$BLOADCONF

			# Check that all the required variables were set by the bootloader configuration.
			if [ -z "$BLOAD_NAME" ] || [ -z "$MAKEFUNCTION" ] || [ -z "$MAKEFILE" ]; then
				# At least one of the required variables was not set, so skip this and move on.
				echo -e "${RED}Bootloader configuration incomplete.  Skipping bootloader for component $COMPONENT.\n${NO_COLOUR}"
				continue
			fi
	
			# Check that the make function specified by the bootloader configuration actually exists.
			if [ `declare -f | grep "$MAKEFUNCTION" | wc -l` == 0 ]; then
				# The specified make function doesn't exist, so skip this and move on.
				echo -e "${RED}Build configuration specifies an invalid make function.  Skipping bootloader for component $COMPONENT.\n${NO_COLOUR}"
				continue
			fi

			# The bootloader configuration was loaded successfully.
			echo -e "${CYAN}Loaded bootloader configuration '$BLOAD_NAME'.\n${NO_COLOUR}"
		fi

		# Now, we compile the bootloader.
		echo -e "${CYAN}Compiling bootloader...\n${NO_COLOUR}"

		# Actually run the appropriate make function for this build configuration.
		$MAKEFUNCTION
	fi
done

# Check if we are supposed to be deleting temporary files after we are finished.
if [ ! $RETAIN ]; then
	# Delete all the temporary files.
	echo -e "${CYAN}Removing temporary files...\n${NO_COLOUR}"

	# Delete the temporary source folders.
	rm -rf  $TCPATH/$TMP_SRC_DIR
else
	# Don't delete any temporary files.
	echo -e "${CYAN}Retaining temporary files.\n${NO_COLOUR}"
fi

# Indicate that we're done.
echo -e "${BOLD_CYAN}All done...\n${NO_COLOUR}"

# All done.
exit 0

