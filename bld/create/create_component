#!/bin/bash

###########################################################################################################################
###															###
### Name:		create_component										###
###															###
### Author:		Zac Frank											###
###															###
### Date Created:	15.11.11											###
###															###
### Type:		Bash Script											###
###															###
### Purpose:		This script gets called by VFstart script, when the user chooses to create a new component. 	###
###			It creates a new folder in src given the name of the component specified by the user, and 	###
###			sets the component configuration depending on the user's input. 				###
###															###
###########################################################################################################################

# FIGURE OUT WHERE WE ARE.

# Determine what the absolute path to the root of the toolchain is.
SCRIPT=`readlink -f $0`
SCRIPTPATH=`dirname $SCRIPT`
TCPATH=$(echo $SCRIPTPATH | sed 's/\/bld.*//')

# DEFINE CONSTANTS.

# Define file names.

TEMPLATE_C_FILE="res/c_template.c"
TEMPLATE_H_FILE="res/h_template.h"
USER_CONFIG_FILE="var/config.cfg"
BUILD_CONFIG_FILE="bld/build_configs.cfg"

# Define the colours used for interface output.
source $TCPATH/bld/common/def_colours

# Define the functions used for preprocessing.
source $TCPATH/bld/preprocess/preprocess

######################################## FUNCTION #########################################
###											###
### Name:		create_template							###
###											###
### Inputs/Outputs:	None								###
###											###
### Purpose:		Creates template source files for the user to build their 	###
###			software from.						     	###
###											###
###########################################################################################

create_template ()
{
	# Create the actual files by coping the templates into the source directory.
	echo -e "${CYAN}Creating template files...\n${NO_COLOUR}"
	cp $TCPATH/$TEMPLATE_C_FILE $TCPATH/src/$NAME/$NAME.c
	cp $TCPATH/$TEMPLATE_H_FILE $TCPATH/src/$NAME/$NAME.h

	# Reset any variables which may have been set by a previous component.
	BCONF_NAME=
	COMPILER=
	MAKEFUNCTION=
	MAKEFILE=
	MCU_CODE=
	OBJCOPY=
	IOHEADER=

	# Check to see if we can find a matching build configuration.
	BCONF="bconf_${TARGET}_${PLATFORM}"
	if [ `declare -f | grep "$BCONF ()" | wc -l` == 0 ]; then
		# No matching build configuration was found, so we can't do the preprocessing.
		echo -e "${RED}No suitable build configuration found.  Cannot preprocess template files.\n${NO_COLOUR}"
		return
	else
		# There is a matching build configuration, so load it.
		echo -e "${CYAN}Loading build configuration ($BCONF)...\n${NO_COLOUR}"
		$BCONF

		# Check that all the required variables were set by the build configuration.
		if [ -z "$BCONF_NAME" ] || [ -z "$COMPILER" ] || [ -z "$MAKEFUNCTION" ] || [ -z "$MAKEFILE" ] || [ -z "$MCU_CODE" ]\
		   || [ -z "$OBJCOPY" ] || [ -z "$IOHEADER" ]; then
			# At least one of the required variables was not set, so skip this component and move on.
			echo -e "${RED}Build configuration incomplete. Cannot preprocess template files.\n${NO_COLOUR}"
			continue
		fi

		# TODO - Actually, maybe some of these would be optional, if they aren't need by all targets?

		# The build configuration was loaded successfully.
		echo -e "${CYAN}Loaded build configuration '$BCONF_NAME'.\n${NO_COLOUR}"
	fi

	# Preprocess the two template files.
	preprocess_template $TCPATH/src/$NAME/$NAME.c
	preprocess_template $TCPATH/src/$NAME/$NAME.h

	# All done.
	echo -e "${CYAN}All done.\n${NO_COLOUR}"	
	return
}

######################################## FUNCTION #########################################
###											###
### Name:		choose_target							###
###											###
### Inputs/Outputs:	None								###
###											###
### Purpose:		Asks the user which target they are using and sets the value	###
###			$TARGET accordingly.						###
###											###
###########################################################################################

choose_target()
{
	# List the possible build configurations.
	BCONFS=`declare -F | grep -o -e "bconf_.*"`
	
	# Iterate through the possible build configurations
	for BCONF in $BCONFS; do
		# Extract the name of the target from the configuration and add it to a list of possible targets.
		TARGETS="`echo $BCONF | cut -d '_' -f 2` $TARGETS"
	done

	# Sort the list of targets and search for duplicates.
	TARGETS="`echo $TARGETS | tr " " "\n" | sort -u -r | tr "\n" " "`"

	# Prompt the user.
	echo -e "${GREEN}Which target would you like to code for? \n${NO_COLOUR}"

	# Create a menu of choices and have the user select one.
	select TARGET in $TARGETS
	do
		# Check if the selected target is actually valid.
		TARGET=$(echo "$TARGETS" | grep -w -o "$TARGET")
		if [ -z "$TARGET" ]; then
			# The selected target was not in the list of targets, so the user is apparently a moron.
			echo -e "${RED}Invalid choice.  Try again.\n${NO_COLOUR}"
		else
			# A legitimate option was selected, so we can go now.
			echo -e "${CYAN}Selected target $TARGET.\n${NO_COLOUR}"
			break
		fi
	done

	# All done.
	return
}

######################################## FUNCTION #########################################
###											###
### Name:		choose_platform							###
###											###
### Inputs/Outputs:	None								###
###											###
### Purpose:		Asks the user which platform (operating system) they wish to	###
###			use and sets the value $PLATFORM accordingly.			###
###											###
###########################################################################################

choose_platform()
{
	# List the possible build configurations.
	BCONFS=`declare -F | grep -o -e "bconf_.*"`
	
	# Iterate through the possible build configurations
	for BCONF in $BCONFS; do
		# Check if this configuration is specific to our chosen target.
		if [ "$TARGET" == `echo $BCONF | cut -d '_' -f 2` ]; then
			# This configuration matches the current target.
	
			# Extract the name of the platform from the configuration and add it to a list of possible platforms.
			PLATFORMS="`echo $BCONF | cut -d '_' -f 3` $PLATFORMS"
		fi
			# Else, the configuration is for some other target, so we ignore it.
	done

	# Sort the list of platforms and search for duplicates.
	PLATFORMS="`echo $PLATFORMS | tr " " "\n" | sort -u -r | tr "\n" " "`"

	# Prompt the user.
	echo -e "${GREEN}Which platform would you like to code for? \n${NO_COLOUR}"

	# Create a menu of choices and have the user select one.
	select PLATFORM in $PLATFORMS
	do
		# Check if the selected platform is actually valid.
		PLATFORM=$(echo "$PLATFORMS" | grep -w -o "$PLATFORM")
		if [ -z "$PLATFORM" ]; then
			# The selected platform was not in the list of platforms, so the user is apparently a moron.
			echo -e "${RED}Invalid choice.  Try again.\n${NO_COLOUR}"
		else
			# A legitimate option was selected, so we can go now.
			echo -e "${CYAN}Selected platform $PLATFORM.\n${NO_COLOUR}"
			break
		fi
	done

	# All done.
	return
}

######################################## FUNCTION #########################################
###											###
### Name:		choose_bootloader						###
###											###
### Inputs/Outputs:	None								###
###											###
### Purpose:		Asks the user which bootloader they wish to use and sets the	###
###			value $BOOTLOADER accordingly.					###
###											###
###########################################################################################

choose_bootloader()
{
	# List the possible bootloader configurations.
	BLOADCONFS=`declare -F | grep -o -e "bload_.*"`
	
	# Iterate through the possible bootloader configurations
	for BLOADCONF in $BLOADCONFS; do
		# Check if this configuration is specific to our chosen target.
		if [ "$TARGET" == `echo $BLOADCONF | cut -d '_' -f 2` ]; then
			# This configuration matches the current target.
	
			# Extract the name of the bootloader from the configuration and add it to a list of possible bootloaders.
			BOOTLOADERS="`echo $BLOADCONF | cut -d '_' -f 3` $BOOTLOADERS"
		fi
			# Else, the configuration is for some other target, so we ignore it.
	done

	# Sort the list of bootloaders and search for duplicates.
	BOOTLOADERS="`echo $BOOTLOADERS | tr " " "\n" | sort -u -r | tr "\n" " "`"

	# Check if the list is empty.  It can be, because its possible to have a build configuration for a target without a suitable bootloader.
	if [ -z "${BOOTLOADERS## }" ]; then
		# There are no suitable bootloaders, so there is no point asking the user to choose one.
		echo -e "${YELLOW}No suitable bootloaders found for this target.\n${NO_COLOUR}"
		return
	fi

	# Prompt the user.
	echo -e "${GREEN}Which bootloader would you like to use for this component? \n${NO_COLOUR}"

	# Create a menu of choices and have the user select one.
	select BOOTLOADER in $BOOTLOADERS
	do
		# Check if the selected bootloader is actually valid.
		BOOTLOADER=$(echo "$BOOTLOADERS" | grep -w -o "$BOOTLOADER")
		if [ -z "$BOOTLOADER" ]; then
			# The selected bootloader was not in the list of bootloaders, so the user is apparently a moron.
			echo -e "${RED}Invalid choice.  Try again.\n${NO_COLOUR}"
		else
			# A legitimate option was selected, so we can go now.
			echo -e "${CYAN}Selected bootloader $BOOTLOADER.\n${NO_COLOUR}"
			break
		fi
	done

	# All done.
	return
}

##################################### MINOR FUNCTIONS ####################################

# Print a usage message.
usage()
{
	# Block-concatenate the message.
	cat << EOF

Usage: $0 [Options]

This script is used, as part of the 'Valley Forge' Embedded Toolchain to create components and update their configurations.

Options:
	-h --help			Show this message.
	-b --batch			Operate in 'batch mode', wherein there are no interactive prompts.
	-n --name <Component Name>	Specify the name of a component to create/update.
	-s --subsystem <Subsystem Name>	Specify the name of the subsystem this component is part of.
	-t --target <Target ID>		Specify the target for this component.
	-p --platform <Platform ID>	Specify the platform for this component.
	-l --loader <Bootloader ID>	Specify the bootloader for this component.
EOF
	# All done.
	return
}

################################ SCRIPT PROPER STARTS HERE ###############################

# PARSE ANY COMMAND LINE PARAMETERS.

# Reset fields to be extracted from the parameters.
NAME=
BATCHMODE=
SUBSYSTEM=
TARGET=
PLATFORM=
BOOTLOADER=

# Define variables required for 'getopt' to work.
PROGNAME=${0##*/} 
SHORTOPTS="hbn:s:t:p:l:"
LONGOPTS="help,batch,name:,subsystem:,target:,platform:,loader:"

# Use 'getopt' to parse the command line options.
ARGS=$(getopt -s bash --options $SHORTOPTS --longoptions $LONGOPTS --name $PROGNAME -- "$@")
eval set -- "$ARGS"

# Handle the parsed parameters.
while true; do
	# Select the appropriate behaviour for each parameter.
	case $1 in
		-h|--help)
			# Just print the usage message and then exit.
			usage
			exit 0
			;;
		-b|--batch)
			# Select batch mode.
			BATCHMODE=1
			;;
		-n|--name)
			# Specify the name of the component to create.
			shift
			NAME="$1"
			;;
		-s|--subsystem)
			# Specify the subsystem of the component to create.
			shift
			SUBSYSTEM="$1"
			;;
		-t|--target)
			# Specify the target of the component to create.
			shift
			TARGET="$1"
			;;
		-p|--platform)
			# Specify the platform of the component to create.
			shift
			PLATFORM="$1"
			;;
		-l|--loader)
			# Specify the bootloader of the component to create.
			shift
			BOOTLOADER="$1"
			;;
		--)
			# We're done parsing options.  We ignore anything else.
			shift
			break
			;;
		*)
			# We ignore anything else.
			shift
			break
			;;
	esac

	# Advance on to the next parameter.
	shift
done

# Parse the build configurations file.
source $TCPATH/bld/common/load_build_configs

# PROMPT THE USER FOR ANY ADDITIONAL INFORMATION.

# Check if we have been supplied the name of the component to create and that we're not in batch mode.
if [ -z $NAME ] && [ ! $BATCHMODE ]; then
	# Since the user might be a moron and keep entering invalid names, we loop until a suitable name is entered.
	while :
	do
		# We will need to prompt the user for the name of the component to create.
		echo -e -n "${GREEN}Enter a name for the component to be created: (No spaces) ${NO_COLOUR}"
		read
		echo -e "" 

		# Check the user actually entered something.
		if [ -z "$REPLY" ]; then
			# We'll just prompt again.
			continue

		# Check if the user actually just wants to exit without creating anything.
		elif [ "$REPLY" == "exit" ]; then
			# Exit the script.
			exit 0

		# Check if the name is a reserved word.
		elif [ "$REPLY" == "none" ] || [ "$REPLY" == "--retain" ] || [ "$REPLY" == "-r" ] || [ "$REPLY" == "--all" ] ||\
		     [ "$REPLY" == "all" ] || [ "$REPLY" == "-a" ] || [ "$REPLY" == "--help" ] || [ "$REPLY" == "-h" ] ||\
		     [ "$REPLY" == "--clean" ] || [ "$REPLY" == "-c" ]; then
			# The name is a reserved word, and thus invalid.  Prompt the user to choose a more suitable name.
			echo -e "${RED}The component name '$REPLY' is an invalid name.  Please choose another name.\n${NO_COLOUR}"

		# Check if the component name contains spaces.
		elif [[ $name == *\ * ]]; then
			# The name contains spaces, which is invalid. Prompt the user to choose a more suitable name.
			echo -e "${RED}The component name must not contain spaces.  Please choose another name.\n${NO_COLOUR}"

		# Check to see if this name is already taken.
		elif [ -d "$TCPATH/src/$REPLY" ]; then
			# The name provided is already taken.  Prompt the user to choose an available name.
			echo -e "${RED}The component '$REPLY' already exists.  Please choose another name.\n${NO_COLOUR}"

		else
			# The name is probably legit, so we move on.
			NAME=$REPLY
			break
		fi
	done

# Check if we have been supplied the name of the component to create and that we're in batch mode.
elif [ -z $NAME ] && [ $BATCHMODE ]; then
	# We haven't been given a name, and we're in batch mode, so can't ask.  So we just have to bail.
	echo -e "${BOLD_RED}FATAL - No name supplied in batch mode.\n${NO_COLOUR}"
	exit 1
fi

# Check if we have been supplied the sub-system name and that we're not in batch mode.
if [ -z $SUBSYSTEM ] && [ ! $BATCHMODE ]; then
	# We haven't been given a subsysytem name, so we need the user to enter one.

	# We will need to prompt the user for the name of the component to create.
	echo -e -n "${GREEN}Enter a subsystem name for the component: ${NO_COLOUR}"
	read
	echo -e ""

	# Pretty much anything goes here.
	SUBSYSTEM=$REPLY

	# TODO - Maybe later we could have a list of known subsystems from which to choose of just a random text field?
fi

# Check if we have been supplied the target type and that we're not in batch mode.
if [ -z $TARGET ] && [ ! $BATCHMODE ]; then
	# We haven't been given a target type, so we need the user to select one.
	choose_target
fi

# Check if we have been supplied the platform type and that we're not in batch mode.
if [ -z $PLATFORM ] && [ ! $BATCHMODE ]; then
	# We haven't been given the platform type, so we need the user to select one.
	choose_platform
fi

# Check if we have been supplied the bootloader type and that we're not in batch mode.
if [ -z $BOOTLOADER ] && [ ! $BATCHMODE ]; then
	# We haven't been given the bootloader type, so we need the user to select one.
	choose_bootloader
fi

# CREATE THE COMPONENT.

# Check if the specified component does not exist yet.
if [ ! -d "$TCPATH/src/$NAME" ]; then
	# This is a new component, so we will need to create a directory for it.
	echo -e "${CYAN}Creating component directory (src/$NAME)...\n${NO_COLOUR}"
	NEW=1
	mkdir $TCPATH/src/$NAME
fi

# TODO - We should check that this actually worked, and if it didn't, bail.

# Create the configuration file for the component, overriding any existing configuration file.
echo -e "${CYAN}Creating configuration file (src/$NAME/$NAME.cfg)...\n${NO_COLOUR}"
echo -e "# Configuration file for component $NAME.\n\nSUBSYSTEM=$SUBSYSTEM\nTARGET=$TARGET\nPLATFORM=$PLATFORM\nBOOTLOADER=$BOOTLOADER\n" > $TCPATH/src/$NAME/$NAME.cfg

# TODO - We should actually check if this works.

# POST-NEW-COMPONENT OPTIONS.

# We only ask the user questions if we're not in batch mode and it's a new component.
if [ ! $BATCHMODE ] && [ $NEW ]; then
	# Ask if the user wants to set this as the current component.
	echo -e -n "${GREEN}Do you wish to make this the current component? (Y/N) ${NO_COLOUR}"
	read -n 1
	echo -e "\n" # NOTE - This is because the read command won't put a newline after it reads a character.	

	# If they responded YES, then set the current component.
	if [[ $REPLY =~ ^[Yy]$ ]]; then
		# We want to set this as the current component.
		sed -i "s^\(tc_curr *= *\).*^\1$NAME^" $TCPATH/$USER_CONFIG_FILE

		# TODO - We should actually check if we can find the config file first.
	fi

	# Ask if the user wants template files to be created.
	echo -e -n "${GREEN}Do you wish for template files to be created for the component? (Y/N) ${NO_COLOUR}"
	read -n 1
	echo -e "\n" # NOTE - This is because the read command won't put a newline after it reads a character.	

	# If they responded YES, then create the template files.
	if [[ $REPLY =~ ^[Yy]$ ]]; then
		# Create the template files.
		create_template
	fi

	# Explain to the user what they should do now.
	echo -e "${BOLD_WHITE}The working directory for component $NAME can now be found at src/$NAME.\n${NO_COLOUR}"
fi

# All done.
echo -e "${CYAN}All done.\n${NO_COLOUR}"
exit 0

