#!/bin/bash

#	Copyright (C) 2012 Unison Networks Ltd
#
#	This program is free software: you can redistribute it and/or modify
#	it under the terms of the GNU General Public License as published by
#	the Free Software Foundation, either version 3 of the License, or
#	(at your option) any later version.
#
#	This program is distributed in the hope that it will be useful,
#	but WITHOUT ANY WARRANTY; without even the implied warranty of
#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#	GNU General Public License for more details.
#
#	You should have received a copy of the GNU General Public License
#	along with this program.  If not, see <http://www.gnu.org/licenses/>

###########################################################################################################################
###															###
### Name:		make_arm											###
###															###
### Author:		Edwin Hayes											###
###															###
### Date Created:	19-03-2012											###
###															###
### Type:		Bash Script											###
###															###
### Purpose:		Provides functions which makes ARM type components.						###
###															###
###########################################################################################################################

# Indicate the file was imported successfully.
echo -e "${CYAN}Imported ARM make-functions.\n${NO_COLOUR}"

######################################## FUNCTION #########################################
###											###
### Name:		makearm_bare							###
###											###
### Inputs/Outputs:	None								###
###											###
### Purpose:		Copies ARM makefile into tmp directory, edits it, and uses it	###
### 			to compile the files that are already there.  This compiles a  	###
###			component which will run upon bare metal.			###
###											###
###########################################################################################

makearm_bare()
{
	# TODO - This.

	# All done.
	echo -e "\n${RED}Bare ARM compilation not implemented.\n${NO_COLOUR}"
	return 0
}

######################################## FUNCTION #########################################
###											###
### Name:		makearm_linux							###
###											###
### Inputs/Outputs:	None								###
###											###
### Purpose:		Copies ARM makefile into tmp directory, edits it, and uses it	###
### 			to compile the files that are already there.  This compiles a  	###
###			component which will run a linux type platform.			###
###											###
###########################################################################################

makearm_linux()
{
	# Perform the standard precompile routine.
	if ! generic_precompile; then
		# There isn't anything to do.
		echo -e "${YELLOW}Nothing to make for component $COMPONENT.\n${NO_COLOUR}"
		return 1
	fi

	# Set up the ARM compiler.
	unpack_armc

	# Copy the relevant makefile in with the source.
	echo -e "${CYAN}Constructing makefile for component $COMPONENT...\n${NO_COLOUR}"
	cp $MAKEFILE $TCPATH/$TMP_SRC_DIR/$COMPONENT

	# Check if there is also a linker script to go with the makefile.
	if [ ! -z $LINKSCRIPT ] && [ -r $LINKSCRIPT ]; then
		# Copy the relevant linker script in with the source.
		cp $LINKSCRIPT $TCPATH/$TMP_SRC_DIR/$COMPONENT/linker_script.ld

		# A linker script is specified, so set the linker flags to refer to it.
		LFLAGS="-T linker_script.ld $LFLAGS"
	fi

	# Update the flags in case they still contain some unevaluated variables.
	CFLAGS=$(eval echo $CFLAGS)
	PFLAGS=$(eval echo $PFLAGS)
	AFLAGS=$(eval echo $AFLAGS)
	LFLAGS=$(eval echo $LFLAGS)

	# ARM targets might require multiple application executables, which which case we need to iterate over each of them.

	# Check if the component configuration lists executables to build.
	if [ -z "$EXECUTABLES" ]; then
		# There is no list of executables, so just look for the default one named after the component.
		EXECUTABLES=${COMPONENT_NAME}
	fi

	# Iterate over the list of executables.
	for EXECUTABLE in $EXECUTABLES; do
		# Update the working makefile with the appropriate values for this executable.	
		sed -ri "s^(MCU *= *)BUILD_INSERTS_MCU_CODE_HERE(\\s.*)?^\1$MCU_CODE\2^" $TCPATH/$TMP_SRC_DIR/$COMPONENT/Makefile
		sed -ri "s^(CC *= *)BUILD_INSERTS_C_COMPILER_HERE(\\s.*)?^\1$C_COMPILER\2^" $TCPATH/$TMP_SRC_DIR/$COMPONENT/Makefile
		sed -ri "s^(PC *= *)BUILD_INSERTS_P_COMPILER_HERE(\\s.*)?^\1$P_COMPILER\2^" $TCPATH/$TMP_SRC_DIR/$COMPONENT/Makefile
		sed -ri "s^(AS *= *)BUILD_INSERTS_ASSEMBLER_HERE(\\s.*)?^\1$ASSEMBLER\2^" $TCPATH/$TMP_SRC_DIR/$COMPONENT/Makefile
		sed -ri "s^(LD *= *)BUILD_INSERTS_LINKER_HERE(\\s.*)?^\1$LINKER\2^" $TCPATH/$TMP_SRC_DIR/$COMPONENT/Makefile
		sed -ri "s^(OBJCOPY *= *)BUILD_INSERTS_OBJCOPY_HERE(\\s.*)?^\1$OBJCOPY\2^" $TCPATH/$TMP_SRC_DIR/$COMPONENT/Makefile
		sed -ri "s^(OBJDUMP *= *)BUILD_INSERTS_OBJDUMP_HERE(\\s.*)?^\1$OBJDUMP\2^" $TCPATH/$TMP_SRC_DIR/$COMPONENT/Makefile
		sed -ri "s^(COMPONENT *= *)BUILD_INSERTS_COMPONENT_HERE(\\s.*)?^\1${COMPONENT_NAME}\2^" $TCPATH/$TMP_SRC_DIR/$COMPONENT/Makefile
		sed -ri "s^(EXECUTABLE *= *)BUILD_INSERTS_EXECUTABLE_HERE(\\s.*)?^\1$EXECUTABLE\2^" $TCPATH/$TMP_SRC_DIR/$COMPONENT/Makefile
		sed -ri "s^(CFLAGS *= *.* *)BUILD_INSERTS_CFLAGS_HERE(\\s.*)?^\1$CFLAGS\2^" $TCPATH/$TMP_SRC_DIR/$COMPONENT/Makefile
		sed -ri "s^(PFLAGS *= *.* *)BUILD_INSERTS_PFLAGS_HERE(\\s.*)?^\1$PFLAGS\2^" $TCPATH/$TMP_SRC_DIR/$COMPONENT/Makefile
		sed -ri "s^(AFLAGS *= *.* *)BUILD_INSERTS_AFLAGS_HERE(\\s.*)?^\1$AFLAGS\2^" $TCPATH/$TMP_SRC_DIR/$COMPONENT/Makefile
		sed -ri "s^(LFLAGS *= *.* *)BUILD_INSERTS_LFLAGS_HERE(\\s.*)?^\1$LFLAGS\2^" $TCPATH/$TMP_SRC_DIR/$COMPONENT/Makefile

		# Actually make the executable.
		echo -e "${CYAN}Making executable $EXECUTABLE ...\n${NO_COLOUR}"
		make -C $TCPATH/$TMP_SRC_DIR/$COMPONENT all

		# NOTE - Don't put anything in here; we need the return value from 'make' below.

		# Check the return value from make, to determine if an error occurred during compilation.
		if [ $? != 0 ]; then
			# Something went wrong.
			echo -e "\n${RED}Compilation error.  Failed to build executable $EXECUTABLE in component $COMPONENT.\n${NO_COLOUR}"
			return 1
		fi
	
		# The compilation worked, so now just copy across the output binaries into the appropriate format.
		mkdir -p $TCPATH/$OUTPUT_DIR/$COMPONENT/${EXECUTABLE%/*}
		$OBJCOPY -O $OUTPUT_TYPE $TCPATH/$TMP_SRC_DIR/$COMPONENT/$EXECUTABLE $TCPATH/$OUTPUT_DIR/$COMPONENT/$EXECUTABLE

		# Check the return value from the object copy.
		if [ $? != 0 ]; then
			# Something went wrong.
			echo -e "\n${RED}Object copy error.  Failed to build executable $EXECUTABLE in component $COMPONENT.\n${NO_COLOUR}"			
			return 1
		fi

		# TODO - Print out the size of the generated file.	
	done

	# All done.
	echo -e "\n${BOLD_WHITE}Build successful.  Output files written to $OUTPUT_DIR/$COMPONENT.\n${NO_COLOUR}"
	return 0
}

######################################## FUNCTION #########################################
###											###
### Name:		makearm_omap4_angstrom_filesystem				###
###											###
### Inputs/Outputs:	None								###
###											###
### Purpose:		Builds an OMAP4 root filesystem for the Angstrom distribution.	###
###											###
###########################################################################################

makearm_omap4_angstrom_filesystem()
{
	# The filesystem is already built (magically), the files just need to be copied across.

	# Select the Angstrom image so that when the toolchain tries to build the bootloader, it uses the right files.
	rm -Rf "${TCPATH}/res/arm/omap4/images"
	mkdir -p "${TCPATH}/res/arm/omap4/images"
	cp -sf "${TCPATH}/res/arm/omap4/angstrom/images/filesystem.tar.bz2" "${TCPATH}/res/arm/omap4/images/filesystem.tar.bz2"
	cp -sf "${TCPATH}/res/arm/omap4/angstrom/images/MLO" "${TCPATH}/res/arm/omap4/images/MLO"
	cp -sf "${TCPATH}/res/arm/omap4/angstrom/images/u-boot.img" "${TCPATH}/res/arm/omap4/images/u-boot.img"
	cp -sf "${TCPATH}/res/arm/omap4/angstrom/images/uImage" "${TCPATH}/res/arm/omap4/images/uImage"

	# Copy the relevant files across to the output directory.
	echo -e "${CYAN}Copying filesystem files for $COMPONENT...\n${NO_COLOUR}"
	cp "${TCPATH}/res/arm/omap4/images/filesystem.tar.bz2" "$TCPATH/${OUTPUT_DIR}/${COMPONENT}/${COMPONENT_NAME}_filesystem.tar.bz2"

	# All done.
	echo -e "${BOLD_WHITE}Build successful.  Output files written to ${OUTPUT_DIR}/${COMPONENT}.\n${NO_COLOUR}"
	return 0
}

######################################## FUNCTION #########################################
###											###
### Name:		makearm_omap4_ubuntu_core_filesystem				###
###											###
### Inputs/Outputs:	None								###
###											###
### Purpose:		Builds an OMAP4 root filesystem for the Ubuntu distribution, 	###
###			based upon the Ubuntu 'Core' Infrastructure.			###
###											###
###########################################################################################

makearm_omap4_ubuntu_core_filesystem()
{
	# Construct a working Ubuntu image.

	# Copy the relevant makefile in with the source.
	echo -e "${CYAN}Constructing makefile for component $COMPONENT filesystem...\n${NO_COLOUR}"
	mkdir -p $TCPATH/res/arm/omap4/ubuntu-core/images
	cp $TCPATH/res/arm/omap4/ubuntu-core/Makefile $TCPATH/res/arm/omap4/ubuntu-core/images/Makefile

	# Update the working makefile with the appropriate values for this component.	
	sed -i "s^\(IMAGE_PATH *= *\)BUILD_INSERTS_IMAGE_PATH_HERE^\1$TCPATH/res/arm/omap4/ubuntu-core/images^" $TCPATH/res/arm/omap4/ubuntu-core/images/Makefile	# NOTE - Using '^' as delimiters.

	# Actually make the file system.
	make -C $TCPATH/res/arm/omap4/ubuntu-core/images all

	# NOTE - Don't put anything in here; we need the return value from 'make' below.

	# Check the return value from make, to determine if an error occurred during compilation.
	if [ $? != 0 ]; then
		# Something went wrong.
		echo -e "\n${RED}Make error.  Failed to build component $COMPONENT filesystem.\n${NO_COLOUR}"
		return 1
	else
		# We produced the image ok.
		echo -e  "\n${CYAN}Obtained up to date filesystem image files.\n${NO_COLOUR}"
	fi

	# Remove the working makefile again.
	rm $TCPATH/res/arm/omap4/ubuntu-core/images/Makefile

	# Select the Ubuntu image so that when the toolchain tries to build the bootloader, it uses the right files.
	rm -Rf "${TCPATH}/res/arm/omap4/images"
	mkdir -p "${TCPATH}/res/arm/omap4/images"
	cp -sf "${TCPATH}/res/arm/omap4/ubuntu-core/images/filesystem.tar.gz" "${TCPATH}/res/arm/omap4/images/filesystem.tar.gz"
	cp -sf "${TCPATH}/res/arm/omap4/ubuntu-core/images/MLO" "${TCPATH}/res/arm/omap4/images/MLO"
	cp -sf "${TCPATH}/res/arm/omap4/ubuntu-core/images/u-boot.img" "${TCPATH}/res/arm/omap4/images/u-boot.img"
	cp -sf "${TCPATH}/res/arm/omap4/ubuntu-core/images/uImage" "${TCPATH}/res/arm/omap4/images/uImage"
	cp -sf "${TCPATH}/res/arm/omap4/ubuntu-core/images/boot.scr" "${TCPATH}/res/arm/omap4/images/boot.scr"

	# Copy the relevant files across to the output directory.
	echo -e "${CYAN}Copying filesystem files for $COMPONENT...\n${NO_COLOUR}"
	cp "${TCPATH}/res/arm/omap4/images/filesystem.tar.gz" "$TCPATH/${OUTPUT_DIR}/${COMPONENT}/${COMPONENT_NAME}_filesystem.tar.gz"

	# TODO - We probaby want to make some final changes to the Ubuntu output file to activate a tty etc.

	# All done.
	echo -e "${BOLD_WHITE}Build successful.  Output files written to ${OUTPUT_DIR}/${COMPONENT}.\n${NO_COLOUR}"
	return 0
}

######################################## FUNCTION #########################################
###											###
### Name:		makearm_omap4_ubuntu_prebuilt_filesystem			###
###											###
### Inputs/Outputs:	None								###
###											###
### Purpose:		Builds an OMAP4 root filesystem for the Ubuntu distribution, 	###
###			based upon prebuilt Ubuntu binary images.			###
###											###
###########################################################################################

makearm_omap4_ubuntu_prebuilt_filesystem()
{
	# Construct a working Ubuntu image.

	# Copy the relevant makefile in with the source.
	echo -e "${CYAN}Constructing makefile for component $COMPONENT filesystem...\n${NO_COLOUR}"
	mkdir -p $TCPATH/res/arm/omap4/ubuntu-prebuilt/images
	cp $TCPATH/res/arm/omap4/ubuntu-prebuilt/Makefile $TCPATH/res/arm/omap4/ubuntu-prebuilt/images/Makefile

	# Update the working makefile with the appropriate values for this component.	
	sed -i "s^\(IMAGE_PATH *= *\)BUILD_INSERTS_IMAGE_PATH_HERE^\1$TCPATH/res/arm/omap4/ubuntu-prebuilt/images^" $TCPATH/res/arm/omap4/ubuntu-prebuilt/images/Makefile	# NOTE - Using '^' as delimiters.

	# Actually make the file system.
	make -C $TCPATH/res/arm/omap4/ubuntu-prebuilt/images all

	# NOTE - Don't put anything in here; we need the return value from 'make' below.

	# Check the return value from make, to determine if an error occurred during compilation.
	if [ $? != 0 ]; then
		# Something went wrong.
		echo -e "\n${RED}Make error.  Failed to build component $COMPONENT filesystem.\n${NO_COLOUR}"
		return 1
	else
		# We produced the image ok.
		echo -e  "\n${CYAN}Obtained up to date filesystem image files.\n${NO_COLOUR}"
	fi

	# Remove the working makefile again.
	rm $TCPATH/res/arm/omap4/ubuntu-prebuilt/images/Makefile

	# Select the Ubuntu image so that when the toolchain tries to build the bootloader, it uses the right files.
	rm -Rf "${TCPATH}/res/arm/omap4/images"
	mkdir -p "${TCPATH}/res/arm/omap4/images"
	cp -sf "${TCPATH}/res/arm/omap4/ubuntu-prebuilt/images/image.img.gz" "${TCPATH}/res/arm/omap4/images/image.img.gz"

	# Copy the relevant files across to the output directory.
	echo -e "${CYAN}Copying filesystem files for $COMPONENT...\n${NO_COLOUR}"
	cp "${TCPATH}/res/arm/omap4/images/image.img.gz" "$TCPATH/${OUTPUT_DIR}/${COMPONENT}/${COMPONENT_NAME}_image.img.gz"

	# TODO - We probaby want to make some final changes to the Ubuntu output file to activate a tty etc.

	# All done.
	echo -e "${BOLD_WHITE}Build successful.  Output files written to ${OUTPUT_DIR}/${COMPONENT}.\n${NO_COLOUR}"
	return 0
}

######################################## FUNCTION #########################################
###											###
### Name:		makearm_omap4_bootloader					###
###											###
### Inputs/Outputs:	None								###
###											###
### Purpose:		Builds the OMAP4 (U-Boot) bootloader for the current component.	###
###											###
###########################################################################################

makearm_omap4_bootloader()
{
	# The U-Boot bootloader should have been already built (magically), the files just need to be copied across.

	# TODO - Check if a filesystem has actually been made, since this is necessary.

	# Check if, instead of a file-system, there is just a binary image, in which case, we'll just assume that it will take care of the bootloader.
	if [ -a ${TCPATH}/res/arm/omap4/images/image.img.gz ]; then
		# Since there is an image, we don't do anything, assuming the image will take care of whatever.
		echo -e "${YELLOW}Found an OMAP4 SD card image.  Assuming this means no bootloader is required.\n${NO_COLOUR}"
		return 0
	fi

	# Copy the relevant files across to the output directory.
	echo -e "${CYAN}Copying bootloader files for $COMPONENT...\n${NO_COLOUR}"
	cp "${TCPATH}/res/arm/omap4/images/MLO" "$TCPATH/${OUTPUT_DIR}/${COMPONENT}/${COMPONENT_NAME}_bootloader_MLO"
	cp "${TCPATH}/res/arm/omap4/images/u-boot.img" "$TCPATH/${OUTPUT_DIR}/${COMPONENT}/${COMPONENT_NAME}_bootloader_u-boot.img"
	cp "${TCPATH}/res/arm/omap4/images/uImage" "$TCPATH/${OUTPUT_DIR}/${COMPONENT}/${COMPONENT_NAME}_bootloader_uImage"
	cp "${TCPATH}/res/arm/omap4/images/boot.scr" "$TCPATH/${OUTPUT_DIR}/${COMPONENT}/${COMPONENT_NAME}_bootloader_boot.scr" 2>/dev/null
	cp "${TCPATH}/res/arm/omap4/images/uInitrd" "$TCPATH/${OUTPUT_DIR}/${COMPONENT}/${COMPONENT_NAME}_bootloader_uInitrd" 2>/dev/null

	# All done.
	echo -e "${BOLD_WHITE}Build successful.  Output files written to $OUTPUT_DIR.\n${NO_COLOUR}"
	return 0
}

