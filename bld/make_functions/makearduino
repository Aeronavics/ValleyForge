#!/bin/bash

#	Copyright (C) 2012 Unison Networks Ltd
#
#	This program is free software: you can redistribute it and/or modify
#	it under the terms of the GNU General Public License as published by
#	the Free Software Foundation, either version 3 of the License, or
#	(at your option) any later version.
#
#	This program is distributed in the hope that it will be useful,
#	but WITHOUT ANY WARRANTY; without even the implied warranty of
#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#	GNU General Public License for more details.
#
#	You should have received a copy of the GNU General Public License
#	along with this program.  If not, see <http://www.gnu.org/licenses/>

###########################################################################################################################
###															###
### Name:		make_arduino											###
###															###
### Author:		Edwin Hayes											###
###															###
### Date Created:	19-03-2012											###
###															###
### Type:		Bash Script											###
###															###
### Purpose:		Provides functions which makes Arduino type components.						###
###															###
###########################################################################################################################

# Indicate the file was imported successfully.
echo -e "${CYAN}Imported Arduino make-functions.\n${NO_COLOUR}"

# Select the source files for the AWK scripts we use.
ARDUINO_AWK_SPLITTER="${TCPATH}/bld/make_functions/awk_makearduino_splitter"
ARDUINO_AWK_PROTOTYPER="${TCPATH}/bld/make_functions/awk_makearduino_prototyper"

######################################## FUNCTION #########################################
###											###
### Name:		makearduino							###
###											###
### Inputs/Outputs:	None								###
###											###
### Purpose:		Prepares Arduino source files in the tmp directory, then copies	###
###			the Arduino makefile into tmp directory, edits it, and uses it	###
###			to compile the files.				     		###
###											###
###########################################################################################

makearduino()
{
	# Perform the standard precompile routine.
	if ! generic_precompile; then
		# There isn't anything to do.
		echo -e "${YELLOW}Nothing to make for component $COMPONENT.\n${NO_COLOUR}"
		return 1
	fi

	# Set up the Arduino compiler.
	unpack_arduinoc

	# NOTE - Arduino targets only support a single application executable, so it is named the same as the component.

	# NOTE - However, we also allow the user to name a specific sketch file, in case they are forced to compile non-compliant code.

	# Because Arduino builds are different to regular ValleyForge C/C++ builds, we need to do some configuration of the source files first.
	echo -e "${CYAN}Configuring Arduino source files...\n${NO_COLOUR}"
	
	# Check if a specific sketch to build was specified for the component.
	if [ -z "${ARDUINO_SKETCH}" ]; then
		# No sketch was specified, so assume it's named after the component.
		ARDUINO_SKETCH="${COMPONENT_NAME}.ino"
	fi
	# We need to handle non-compliant nesting (since Arduino projects don't play nicely with ValleyForge) where the parent file isn't in the root.
	ARDUINO_BUILD_DIR=$TCPATH/$TMP_SRC_DIR/$COMPONENT/${ARDUINO_SKETCH}
	ARDUINO_BUILD_DIR=${ARDUINO_BUILD_DIR%/*}
	# Check if the sketch file we have decided to build actually exists.
	if [ ! -f "${ARDUINO_BUILD_DIR}/${ARDUINO_SKETCH##*/}" ]; then
		# The sketch file doesn't exist, so we have to abort.
		echo -e "${RED}The specified sketch file (${ARDUINO_SKETCH}) does not exist.  Failed to build component $COMPONENT.\n${NO_COLOUR}"
		return 1
	fi

	# We convert the Arduino PDE/INO file format into a real CPP file which can be compiled.

	# NOTE - LC_ALL needs to be exported to 'C' to get case-sensitive sorting, which is important since stupidly the Ardupilot code depends upon it.

	# List the sketch source files (PDE/INO) other than the parent.
	export LC_ALL=C
	ARDUINO_PDE_FILES=`find "$ARDUINO_BUILD_DIR" -not -name "${ARDUINO_SKETCH##*/}" -name "*.pde" -o -not -name "${ARDUINO_SKETCH##*/}" -name "*.ino" | sort`
	export LC_ALL=

	# NOTE - The actual conversion logic is performed via a set of AWK scripts, which are stored as separate files.

	# Convert the PDE/INO's to a CPP by adding function prototypes and merging them all together.
	echo -e "${CYAN}\tConverting PDE/INO files into a CPP file...\n${NO_COLOUR}"
	ARDUINO_CPP_FILE="${ARDUINO_BUILD_DIR}/${ARDUINO_SKETCH##*/}"
	ARDUINO_CPP_FILE="${ARDUINO_CPP_FILE%.*}.cpp"
	awk -v mode=header -f "${ARDUINO_AWK_SPLITTER}" "${ARDUINO_BUILD_DIR}/${ARDUINO_SKETCH##*/}" ${ARDUINO_PDE_FILES} > ${ARDUINO_CPP_FILE}
	echo "#line 1 \"autogenerated\"" >> ${ARDUINO_CPP_FILE}
	awk -f ${ARDUINO_AWK_PROTOTYPER} "${ARDUINO_BUILD_DIR}/${ARDUINO_SKETCH##*/}" ${ARDUINO_PDE_FILES} >> ${ARDUINO_CPP_FILE}
	awk -v mode=body -f ${ARDUINO_AWK_SPLITTER} "${ARDUINO_BUILD_DIR}/${ARDUINO_SKETCH##*/}" ${ARDUINO_PDE_FILES} >> ${ARDUINO_CPP_FILE}
	# Then remove the PDE/INO files.
	rm ${ARDUINO_PDE_FILES} $TCPATH/$TMP_SRC_DIR/$COMPONENT/${ARDUINO_SKETCH}

	# Since Arduino-mk can't detect them, make a list of all the user libraries we expect to use.

	# Only create a user library listing if we specified a library directory to use.
	if [ -n "${ARDUINO_LIB_DIR}" ]; then
		# Check if the specified library directory actually exists.
		if [ -d "$TCPATH/$TMP_SRC_DIR/$COMPONENT/${ARDUINO_LIB_DIR}" ]; then
			# List all of the library directories we want to include.
			echo -e "${CYAN}\tDetecting user library dependencies (${ARDUINO_LIB_DIR})...\n${NO_COLOUR}"

			# We do something which approximates dependency detection here.

			# Get a list of all the imports from the CPP file.
			ARDUINO_IMPORTS=`cat "${ARDUINO_CPP_FILE}" | grep -E '^#include\\s+(\\"|<)\\w+\\.h(\\"|>)' | sed -r 's^#include\\s+(\\"|<)^^g' | sed -r 's^(\\"|>).*$^^'`
		
			# Iterate over each of the imported header files.
			ARDUINO_USER_LIBRARIES=
			for HEADER_FILE in ${ARDUINO_IMPORTS}; do
				# Check if this header file is somewhere in the user libraries folder.
				USER_LIBRARY=`find "$TCPATH/$TMP_SRC_DIR/$COMPONENT/${ARDUINO_LIB_DIR}" -name "${HEADER_FILE}"`
				USER_LIBRARY="${USER_LIBRARY%/*}"	# Cut the header file name off.
				USER_LIBRARY="${USER_LIBRARY##*/}"	# Cut the root library path off.

				# Check if we actually found a matching library.
				if [ -z "${USER_LIBRARY}" ]; then
					# We didn't find a matching library, so just move on.
					continue
				fi

				# Check if the library is already in the of libraries.
				if [ -n "`echo ${ARDUINO_USER_LIBRARIES} | grep \"\b${USER_LIBRARY}\b\"`" ]; then
					# The library is already in the list, so just move on.
					continue
				fi

				# Add the folder containing this header to the list of user libraries.
				ARDUINO_USER_LIBRARIES+="${USER_LIBRARY} "
			done
			echo -e "${NO_COLOUR}\t${ARDUINO_USER_LIBRARIES}\n${NO_COLOUR}"
		else
			# It seems a bit strange the specified library directory didn't exist.
			echo -e "${YELLOW}\tThe specified Arduino user library directory (${ARDUINO_LIB_DIR}) didn't exist.\n${NO_COLOUR}"
			ARDUINO_USER_LIBRARIES=
		fi
	else
		# Indicate there was no library directory specified.
		echo -e "${CYAN}\tNo Arduino user library directory specified.\n${NO_COLOUR}"
		ARDUINO_USER_LIBRARIES=
	fi

	# If we are using a specific Arduino 'core', then we'll need to indicate this to arduino-mk.

	# TODO - The default paths need to be calculated depending on the type of Arduino.

	# By default, we use the regular arduino core.
	ARDUINO_VARI_PATH=
	if [ -n "${ARDUINO_VARI_DIR}" ]; then
		# Specify the path to the core variants directory.
		ARDUINO_VARI_PATH="${ARDUINO_VARI_DIR}"
	else
		# Specify the default core variants directory.
		ARDUINO_VARI_PATH="$TCPATH/tmp/tmp_compiler/arduino/arduino-dist/hardware/arduino/avr/variants"
	fi
	# Leave the core directory path blank by default, so arduino-mk uses the regular core.
	ARDUINO_CORE_PATH=
	if [ -n "${ARDUINO_CORE_DIR}" ]; then
		# Specify the path to the core directory.
		ARDUINO_CORE_PATH="${ARDUINO_CORE_DIR}"
	else
		# Specify the default core directory.
		ARDUINO_CORE_PATH="$TCPATH/tmp/tmp_compiler/arduino/arduino-dist/hardware/arduino/avr/cores/arduino"
	fi

	# Now, work out exactly what we will need to have as our include path.

	# Iterate over each user library.
	ARDUINO_INCLUDE_LIST="-I ${ARDUINO_BUILD_DIR} "
	for USER_LIBRARY in ${ARDUINO_USER_LIBRARIES}; do
		# Make a list of directories to include.
		ARDUINO_INCLUDE_LIST+="-I ${ARDUINO_LIB_DIR}/${USER_LIBRARY} "
	done
	# Add the Arduino core directories we selected.
	ARDUINO_INCLUDE_LIST+="-I ${ARDUINO_CORE_PATH} -I ${ARDUINO_VARI_PATH}/mega "

	# Because Arduino components often don't comply with out dependency requirements, we need to add a bunch of libraries onto the include path.
	CFLAGS="${CFLAGS} ${ARDUINO_INCLUDE_LIST}"
	PFLAGS="${PFLAGS} ${ARDUINO_INCLUDE_LIST}"

	# Update the flags in case they still contain some unevaluated variables.
	CFLAGS=$(eval echo $CFLAGS)
	PFLAGS=$(eval echo $PFLAGS)
	AFLAGS=$(eval echo $AFLAGS)
	LFLAGS=$(eval echo $LFLAGS)

	# Copy the relevant makefile in with the source.
	echo -e "${CYAN}Constructing makefile for component $COMPONENT...\n${NO_COLOUR}"
	cp -f $MAKEFILE "$TCPATH/$TMP_SRC_DIR/$COMPONENT/Makefile"

	# Update the working makefile with the appropriate values for this component.
	sed -ri "s^(CC *= *)BUILD_INSERTS_C_COMPILER_HERE(\\s.*)?^\1$C_COMPILER\2^" "$TCPATH/$TMP_SRC_DIR/$COMPONENT/Makefile"
	sed -ri "s^(PC *= *)BUILD_INSERTS_P_COMPILER_HERE(\\s.*)?^\1$P_COMPILER\2^" "$TCPATH/$TMP_SRC_DIR/$COMPONENT/Makefile"
	sed -ri "s^(AS *= *)BUILD_INSERTS_ASSEMBLER_HERE(\\s.*)?^\1$ASSEMBLER\2^" "$TCPATH/$TMP_SRC_DIR/$COMPONENT/Makefile"
	sed -ri "s^(LD *= *)BUILD_INSERTS_LINKER_HERE(\\s.*)?^\1$LINKER\2^" "$TCPATH/$TMP_SRC_DIR/$COMPONENT/Makefile"
	sed -ri "s^(OBJCOPY *= *)BUILD_INSERTS_OBJCOPY_HERE(\\s.*)?^\1$OBJCOPY\2^" "$TCPATH/$TMP_SRC_DIR/$COMPONENT/Makefile"
	sed -ri "s^(OBJDUMP *= *)BUILD_INSERTS_OBJDUMP_HERE(\\s.*)?^\1$OBJDUMP\2^" "$TCPATH/$TMP_SRC_DIR/$COMPONENT/Makefile"
	sed -ri "s^(COMPONENT *= *)BUILD_INSERTS_COMPONENT_HERE(\\s.*)?^\1${COMPONENT_NAME}\2^" "$TCPATH/$TMP_SRC_DIR/$COMPONENT/Makefile"
	sed -ri "s^(EXECUTABLE *= *)BUILD_INSERTS_EXECUTABLE_HERE(\\s.*)?^\1${ARDUINO_SKETCH%.*}\2^" "$TCPATH/$TMP_SRC_DIR/$COMPONENT/Makefile"
	sed -ri "s^(CFLAGS *= *.* *)BUILD_INSERTS_CFLAGS_HERE(\\s.*)?^\1$CFLAGS\2^" "$TCPATH/$TMP_SRC_DIR/$COMPONENT/Makefile"
	sed -ri "s^(PFLAGS *= *.* *)BUILD_INSERTS_PFLAGS_HERE(\\s.*)?^\1$PFLAGS\2^" "$TCPATH/$TMP_SRC_DIR/$COMPONENT/Makefile"
	sed -ri "s^(AFLAGS *= *.* *)BUILD_INSERTS_AFLAGS_HERE(\\s.*)?^\1$AFLAGS\2^" "$TCPATH/$TMP_SRC_DIR/$COMPONENT/Makefile"
	sed -ri "s^(LFLAGS *= *.* *)BUILD_INSERTS_LFLAGS_HERE(\\s.*)?^\1$LFLAGS\2^" "$TCPATH/$TMP_SRC_DIR/$COMPONENT/Makefile"
	sed -ri "s^(LOOSE_OBJECTS *= *.* *)BUILD_INSERTS_LOOSE_OBJECTS_HERE(\\s.*)?^\1$LOOSE_OBJECTS\2^" "$TCPATH/$TMP_SRC_DIR/$COMPONENT/Makefile"
  
	# Actually make the component.
	echo -e "${CYAN}Making component $COMPONENT ...\n${NO_COLOUR}"
	make -C "$TCPATH/$TMP_SRC_DIR/$COMPONENT" all

	# NOTE - Don't put anything in here; we need the return value from 'make' below.

	# Check the return value from make, to determine if an error occurred during compilation.
	if [ $? != 0 ]; then
		# Something went wrong.
		echo -e "\n${RED}Compilation error.  Failed to build component $COMPONENT.\n${NO_COLOUR}"
		return 1
	fi
	
	# The compilation worked, so now just copy across the output binaries.
	mkdir -p $TCPATH/$OUTPUT_DIR/$COMPONENT
	$OBJCOPY -O ihex "$TCPATH/$TMP_SRC_DIR/$COMPONENT/${ARDUINO_SKETCH%.*}" $TCPATH/$OUTPUT_DIR/${COMPONENT}/${COMPONENT_NAME}.hex

	# Check the return value from the object copy.
	if [ $? != 0 ]; then
		# Something went wrong.
		echo -e "\n${RED}Object copy error.  Failed to build component $COMPONENT.\n${NO_COLOUR}"			
		return 1
	fi
	echo -e ""

	# Print out details of the size of the generated hex file.
	echo -e "${WHITE}Output file size details:\n${NO_COLOUR}"
	$SIZE --format=avr --mcu=${MCU_CODE} --totals "$TCPATH/$TMP_SRC_DIR/$COMPONENT/${ARDUINO_SKETCH%.*}"
	$SIZE --format=SysV --totals $TCPATH/$OUTPUT_DIR/${COMPONENT}/${COMPONENT_NAME}.hex

	# All done.
	echo -e "${BOLD_WHITE}Build successful.  Output files written to $OUTPUT_DIR/$COMPONENT.\n${NO_COLOUR}"
	return 0
}

