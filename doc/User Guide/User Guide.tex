% !TEX TS-program = pdflatex
% !TEX encoding = UTF-8 Unicode
% These two above lines are to specify the encoding scheme of THIS, the input file.

% DOCUMENT HEADER.

% Declare the document.
\documentclass[a4paper, oneside, 11pt, titlepage, onecolumn, openright]{report}

% INCLUDE REQUIRED PACKAGES.

% Package to support disabling output for fast syntax checking.
\usepackage{syntonly}

% Package to support logical operations.
\usepackage{ifthen}	

% Package adding some useful symbol macros.
\usepackage{textcomp}

% Package which allows the use of graphs, and ensures they work with pdftex.
\usepackage[pdftex]{color, graphicx}

% Package which sets input encoding.
\usepackage{inputenc} 

% Package allowing improved page layout configuration.
\usepackage{geometry}

% Package which allows better configuration of section heading appearance.
\usepackage{sectsty}

% Package which adds support for fancy headers.
\usepackage{fancyhdr}

% Package which modifies paragraph spacing options.
\usepackage[parfill]{parskip}

% Packages which adds support for better looking tables.
\usepackage{booktabs}

% Package which adds support for better arrays/matrices in maths environments.
\usepackage{array}

% Package which adds support for flexible list environments.
\usepackage{paralist}

% Package which adds support for improved verbatim blocks.
\usepackage{verbatim}
\usepackage{moreverb}

% Package which allows adding multiple figures to a single float.
\usepackage{subfig}

% Package for binding the bibligraphy into the ToC.
\usepackage[nottoc,notlof,notlot]{tocbibind}

% Package allowing customization of the ToC, LoF and LoT.
\usepackage[titles,subfigure]{tocloft}

% Package which allows importing of multi-page PDF documents.
\usepackage{pdfpages}

% Package which lets you put in source code
\usepackage{listings}

% OUTPUT CONFIGURATION OPTIONS.

% Disable generation of output if we just want to check the syntax.
%\syntaxonly

% If this document is going to be printed rather than viewed online, we make some optimizations.
\newcommand{\pdfforprinting}

% DOCUMENT PREAMBLE.

% Specify the input file encoding.
\inputencoding{utf8}

% Configure page layout options.
\geometry{a4paper}
\geometry{margin=2.5cm}
\geometry{portrait}

% Update PDF page layout to match page geometry.
\pdfpagewidth=\paperwidth
\pdfpageheight=\paperheight

% Set the title attributes.
\newcommand{\projecttitle}{ValleyForge Embedded Toolchain}
\newcommand{\documenttitle}{User Guide}
\title{\projecttitle \\ \documenttitle}
\author{Zac Frank \& Paul Bowler}
\date{\today}

% Modify the paragraph style.  This adds roughly a single line between paragraphs.
\setlength{\parindent}{0pt}
\setlength{\parskip}{1em plus 0.5ex minus 0.2ex}

% Modify the line spacing.  This allows a line spacing factor for proofing copies.
\linespread{1.0}

% Select fonts to use for sections.
\allsectionsfont{\sffamily\mdseries\upshape}

% Configure how headers behave.
\pagestyle{fancy} % Options are: empty , plain or fancy.
\renewcommand{\headrulewidth}{0pt}
\lhead{}\chead{}\rhead{}
\lfoot{}\cfoot{\thepage}\rfoot{}

% Configure some improved support for including source code.
\def\sourcetabsize{4}
\newenvironment{sourcestyle}{\begin{scriptsize}}{\end{scriptsize}}
\def\sourceinput#1{\par\begin{sourcestyle}\verbatimtabinput[\sourcetabsize]{#1}\end{sourcestyle}\par}

% Configure the hyperref package.  Due to some magic, this MUST be last in the preamble.
\usepackage[pdftex, bookmarks, pdfstartview={XYZ null null 1.25}]{hyperref}
\ifthenelse{\not{\isundefined{\pdfforprinting}}}
	{
		% Remove colored links since the PDF is going to be printed.
		\hypersetup{colorlinks=false}}  
	{
		% Add coloured links since the PDF will be viewed online.
		\hypersetup{colorlinks=true}
		\hypersetup{linkcolor={blue}}
	}
\hypersetup{pdftitle=\projecttitle~--~\documenttitle}
\hypersetup{pdfauthor=\@author}

% BEGIN THE DOCUMENT PROPER.
\begin{document}

	% Create the title page.
	\maketitle
	
	% Insert the table of contents (ToC).
	\clearpage
	\tableofcontents

	% THE ACTUAL GIST OF THE DOCUMENT STARTS HERE.

	% A report has chapters as the top level sectioning command (and parts).	

	% Make sure the body starts on a new page.
	\clearpage

	\part{The ValleyForge Toolchain}
		\label{part:toolchain}

		\chapter{Introduction}
			\label{c:Introduction}
			
			\section{Background}
				\label{s:Introduction:Background}
				
				Modern autonomous systems, such as Unmanned Aerial Systems (UAS), are extremely complicated, often composed of a multitude of embedded devices which need to operate in conjunction with one another in order to deliver reliable autonomous behaviour.  Development of software for such applications can be particularly daunting, especially in light of the fact that such software is often mission-critical, with considerable penalties for even seemingly minor failures.
				
				Additionally, the development period is often lengthened due to the amount of time lost setting up the software tools neccesary to develop the software.  In the cases of systems composed of many different devices, this is made worse by the need to become acclimatized to different programming paradigms, set up device specific configurations, and track down suitable libraries to provide specific functionality.
				
				The ValleyForge Toolchain attempts to make development of software for these sorts of applications by abstracting away much of the complication of configuring a toolchain, finding suitable libraries and documentation, etc.  The toolchain provides automation of the build process for a range of common hardware typical of these sorts of applications, hardware abstraction libraries to provide control of peripherals through a common interface, plus documentation, code-generation (eventually!) and other functionality to make development of complicated systems easier, whilst maximizing the reliability and maintainability which is critical in high-end embedded applications.
			
			\section{Terminology}
				\label{s:Introduction:Terminology}
				
				For the purposes of the ValleyForge toolchain, some specific terminology is used to refer to the physical breakdown of the thing being programmed, as well as the software controlling it.  The breakdown (and thus the terminology) is quite specific, so as to avoid confusion:
				
				\paragraph{System}	In the context of the toolchain, refers to the `thing' which is being programmed, as viewed by the \emph{end-user}.  For a UAS, this may be the aerial vehicle.  For a spacecraft, it may be a satellite, plus ground station software.  Regardless, each `system' consists of a number of component parts, which need to be programmed in collaboration so as to interoperate correctly.  In many IDE's, this might be called a single `project' (though that doesn't neccesarily apply here, because the toolchain doesn't assume that the user uses a single IDE to write the software for all the different parts of the `system').  The software for a single `system' is contained within a single unique instance of the ValleyForge toolchain (it probably also has its own source control repository).
				
				\paragraph{Component}  Refers to the individual programmable devices which form the complete `system'.  In the context of the toolchain, each component contains a single programmable device (note that this may, or may not, align with what constitutes individual `components' in terms of the physical construction of the product).  Accordingly, each component has an individually named subfolder in the \texttt{src} directory of the project, which contains a number of source files which can be compiled in order to generate the executable code which is to be loaded onto that particular device.
				
				\paragraph{Task}  Refers to individual processes/threads, on multi-tasking capable platforms.  Support for these has yet to be implemented.
				
				\paragraph{Sub-System}  Refers to a logical grouping of components, in order to better classify how they fit into the system as a whole.  Each component can be marked as belonging to a particular `sub-system'.  This does not affect the operation of the toolchain in any way, it simply serves as a guide for users.
				
				\paragraph{Target}  Refers to the hardware configurations with which the toolchain is compatible.  Generally, each target describes a particular microcontroller/processor (or series thereof), although a `target' may also be more specific, referring to a particular integrated configuration of a microcontroller: for instance, `OMAP3530' (a particular processor), `OMAP3' (a series of processors) or `Gumstix' (a particular device).  Regardless, each `target' is suitably specific that by selecting that target, the toolchain is able to build software that will run on this device, without further configuration of the toolchain.
				
				\paragraph{Platform}  Refers to the software platform (or `operating system') which will be running on the target, and upon which the software created by users of the toolchain will be running.  This will either be `bare metal', meaning that the user's code will run directly on the target without an operating system, or the name of some operating system.  Note that not all platforms are compatible with all targets, some targets may only support a single platform.
				
			\section{Scope \& Objectives}
				\label{s:Introduction:Scope & Objectives}
				
				ValleyForge is primarily intended for use in the development of Unmanned Aerial Systems, and other autonomous embedded systems (with a tendency towards aeronautical applications).  Accordingly, the design and scope of the toolchain are optimized for these applications; emphasis is placed on reliability, consistency, and maintainability, all critical features in mission-critical embedded environments.  However, the toolchain may also be useful in a wide range of other embedded development situations, so long as it is understood that the toolchain is not trying to be everything to everyone.
				
				The toolchain is targetted at processors and software platforms which are commonly used in the development of autonomous systems.  Since a typical UAS may require a number of different components of differing complexity, a range of target types are supported: from lightweight AVR microcontrollers, up to multicore ARM processors.  Equally, a range of software platforms are also supported, from single-threaded bare metal up to complete POSIX compliant operating-systems.
				
				It is important to understand that whilst ValleyForge is intended to offer stability and reliability development for mission-critical applications, it is currently under development.  At present, only a limited subset of features are completely implemented.  It is expected that as the toolchain is used, demand for specific features will lead to these features being implemented by users.
			
		\chapter{Getting Started}
			\label{c:Getting Started}

			This section will show you how to install the ValleyForge toolchain on your computer, and how to start using it to write code for a device.

			\section{Installation }
				\label{s:Getting Started:Installation}

				It is assumed that the user has the latest version of Ubuntu installed. If not, the latest version can be downloaded from \url{http://ucmirror.canterbury.ac.nz/linux/ubuntu-releases/}. This image can be burned onto a disc, the computer booted from the disc, and on-screen instructions followed.
			
Once Ubuntu has been installed, we need to install the packages that do not come preinstalled with Ubuntu but are necessary for the toolchain to run. Most of these packages can be installed using the Debian Package repository. To install these packages, open the terminal, and enter:
			
				\begin{lstlisting}
sudo apt-get install byacc flex gcc-avr avr-libc
				\end{lstlisting}

If the user is programming the AT32UC3C0512C, don't worry, the AVR32 compiler and headers are included in the toolchain itself.

Next we will install the toolchain itself. Navigate to the directory where you want the toolchain to reside. This will contain a subdirectory called ``src'' where all your source code will reside.
To download the toolchain to your working directory, type at the command line: \newline

				\begin{lstlisting}
sudo git clone ssh://UCUnison1.canterbury.ac.nz/data/git_data/ValleyForge
				\end{lstlisting}

			\section{Using the Toolchain }
				\label{s:Getting Started:Using The Toolchain}
			
				You are now ready to start using the ValleyForge Toolchain. Navigate to the toolchain directory, and into the subdirectory ``bld''. 

If the toolchain has been used by someone else between being cloned into its directory and now, then run the script ``resettc'', by typing: \newline

				\begin{lstlisting}
./resettc
				\end{lstlisting}

 
Now run the ``VFstart'' script. This will be your main interface to the toolchain, and will take care of creating and deleting components, as well as keeping track of component properties. A prompt will appear, asking you provide your user information. This will aid in creating template-based source files for you to start programming with.  You may choose not to provide this information, but will have to fill it in yourself in template files should you let the interface create them.
 
Follow the onscreen prompts to let the toolchain carry out its operations.

				\subsection{Creating a New Component}
					\label{ss:Getting Started:Using The Toolchain:Create New Component}
			
				To create a new Component, run the VFstart script, and enter ``C'' into the terminal. Choose the microprocessor you are programming on, and then when prompted, enter the name of your component. The name should not contain any spaces and should not be one of the words ``none'', ``all'', or ``exit''. Follow the onscreen prompts to complete the creation of a new component. 

If a bootloader is available for your component, you will be asked to specify which bootloader you wish to use for your component. You will then be prompted to choose some other parameters. If you aren't sure about these, don't worry, you can change them later by going to your component source folder, opening the config file, and editing the required fields. A detailed description of the bootloader options can be found in section [TODO].

Electing to create template files will place two source files (a component.h and a component.cpp or .c) files in your component's source folder, containing component details, and outlining a structure for your source files' layout. The bare metal templates contain no code other than an empty main function, while the FreeRTOS templates contain an example task to help get you started.

You will then be prompted to decide whether this component will be your active component. Your default, or active component is the one that will be acted on when you don't specify a component, for example when the build script is called with no arguments. If you have no other components, the component being created will automatically become your active component and you will not be prompted.

Once you have created your new component, a configuration file will also be placed in its source folder. It contains information such as which compiler to use, which micro the component will be programmed on to, and which platform is being used.

You can type exit at any time to exit back to the terminal.

				\subsection{Deleting Components}
					\label{ss:Getting Started:Using The Toolchain:Deleting Components}

					To delete a component, start the VFstart script, and choose ``Delete''. A list of all your components should appear. Select the component you wish to delete, and confirm the deletion when prompted.

You can type exit at any time to exit back to the terminal.

				\subsection{Changing the Active component}
					\label{ss:Getting Started:Using The Toolchain:Changing the Active component}

					To change which component is the active component, run the VFstart script, choose Edit, and select ``Activate Component''. The list of components will come up, and you will be able to choose which one you want to set as your active component.

				\subsection{Changing User Info}
					\label{Changing the Active component:Changing User Info} 
			
					To change your user info, run the VFstart script, choose Edit, and select ``Edit Settings''. Follow the on screen prompts to change the user information.

			\section{Building Components}
				\label{s:Getting Started:Building Components}

				To compile a component, navigate through the terminal to the ``bld'' directory. To compile the active component, at the terminal, type:

				\begin{lstlisting}
./build
				\end{lstlisting}

The output hex file, if compilation is successful, will be found in the bin folder of the toolchain directory.

To compile a component other than the active one, add the component's name after the ./build command. 
			
		\chapter{Scripts}
			\label{c:Scripts}
		
			This chapter will outline the function of each major script that the user is expected to interact with directly.
		
There are six of these:
			
			\begin{itemize}
		
				\item VFstart

				\item build

				\item create\_component

				\item create\_library

				\item create\_files

				\item create\_library files
		
			\end{itemize} 
	
			\section{VFstart}
				\label{s:Scripts:VFstart}
			
				This is your main interface to the toolchain, and is used for creating, modifying, and deleting components. Most of the functionality is described above in the quick start guide (\S\ref{c:Getting Started}), but a couple of more things can be added.  The VFstart script can be run with parameters to change how it will behave. It has the following parameters:
	
				\begin{itemize}
			
					\item \texttt{-h --help}: Show the usage message.
				
					\item \texttt{-b --block}: `Block mode': do not quit out of the toolchain interface after a single operation.

				\end{itemize} 		

These are entered (in either short or long form) into the terminal after the name of the script, like so:

				\begin{lstlisting}
./VFstart -b
				\end{lstlisting}
			
			\section{build}
				\label{s:Scripts:build}

				Use this script to compile your code. It produces the compiler's output to the terminal so you can debug using it.  The build script, like others, has parameters and flags that can passed to it. It has the following:
			
				\begin{itemize}
			
					\item \texttt{-h --help} Show the usage help message.
			
					\item	\texttt{-a --all} Build all components. This will iterate through each component and attempt to build them one after another.  If the build of one component fails, the other components will still be compiled.
			
					\item	\texttt{-r --retain} Retain temporary files at completion of build. All files used to build the component will be retained in the \texttt{tmp} directory.
			
					\item	\texttt{-l --loader} Build the bootloader for each component as well as the `application code'. The bootloader will be compiled as well, and stored in the bin directory as ``COMPONENT\_NAME\_bootloader.hex''.  At some later stage, there might also be an option two merge the bootloader and application code into a single binary, ready for flashing.
			
					\item	\texttt{-p --postpack} After the build operation has completed, pack up (remove) any compilers or other tools which needed to be unpacked as part of the build process.  This will save space and tidy things up, but means that the tools will need to be unpacked again next time, so subsequent build runs may be slower than they would be otherwise.			
			
					\item	\texttt{-n --name <Component Name>}	Specify the name of a component to build. You can put multiple component names here (space separated), and the script will build all of them. When specifying multiple component names, this must be the \emph{last} option provided to the script.
			
					\item   \texttt{--nohal} Do not include the ValleyForge HAL when compiling the project.  This is useful if the component is using an alternate HAL (for instance, when compiling an Arduino project, and including the Arduino hardware libraries manually).
			
				\end{itemize} 			

		\chapter{Bootloaders}
			\label{c:Bootloaders}

			The options prompted when creating a new component with bootloader are described below:
		
			\begin{itemize}

				\item \textbf{Blink LED Port}. Specify which port will contain the pin that you will use as a bootloader status LED.

				\item \textbf{Blink LED Pin}. Specify which pin on this port will be the status LED.

				\item \textbf{LED Logic}. Specify which voltage level will turn the status LED on or off.

				\item \textbf{Force Bootloader Port}. Specify which port will contain the pin that will be used by the external to signal to your microprocessor that new firmware is available.

				\item \textbf{Force Bootloader Pin}. Specify which pin on this port will be the Force Bootloader pin.

				\item \textbf{Force Bootloader Logic}. Specify which voltage level will signal new firmware is available.

				\item \textbf{Clock Speed}. Specify, in MHz, the clock speed of the microprocessor.

				\item \textbf{Startup State EEPROM Address}. Elect an EEPROM address which the microprocessor will use to determine whether the processor last shut down cleanly. This will affect how the bootloader behaves.

			\end{itemize}

	\part{The ValleyForge Hardware Abstraction Libraries}
		\label{part:hal}

		\chapter{Hardware Abstraction Libraries}
			\label{c:Hardware Abstraction Libraries}
			
			Any of the \textbf{\texttt{hal}} modules may be included in a project by using the pre-processor include command \textbf{\texttt{\#include}} followed by the name of the module and prefixed by the \textbf{\texttt{hal}} path.
			
e.g \textbf{\texttt{\#include "hal/gpio.h"}}
			
			\section{Modules}
				\label{s:Hardware Abstraction Libraries:Modules}
	
				The current modules that are fully implemented include:
			
				\begin{itemize}

					\item \textbf{\texttt{gpio}}. A user uses the \texttt{pin\_grab} function to be given a class instance of a pin, which they can then manipulate until they relinquish hold on it again. 

					\item \textbf{\texttt{tc}}. The user is given an instance of a timer class and is able to use this to manipulate the timers. 
					
					\item \textbf{\texttt{mem}}. The memory module writes to EEPROM. 

					\item \textbf{\texttt{watchdog}}. This implements simple watchdog timers.

					\item \textbf{\texttt{usart}}. The USART module caters for serial communication between the target and a host of other devices. The implementation of the module allows a user to initialise a USART channel with a host of options, transmit and receive data as well as relinquish control of it.
			
				\end{itemize}

			\section{\textbf{\texttt{gpio}} Module}
				\label{s:Hardware Abstraction Libraries:gpio Module}
				
				The \textbf{\texttt{gpio}} module allows the user to interact with the target's General Purpose I/O (GPIO) hardware. The module caters for the the ability to set the input/output functionality of a GPIO pin, set the pin's output logic, read the logic value of the pin and attach or disable interrupt functions to pins that support this functionality.

				\subsection{\textbf{\texttt{grab}} Function}
					\label{ss:Hardware Abstraction Libraries:gpio Module:grab Function}
		
					The \textbf{\texttt{grab}} function allows the user to create an instance of a GPIO pin that they can then use through the available methods in the \textbf{\texttt{gpio}} class. 
			
This function takes as an argument a \textbf{\texttt{gpio\_pin\_address}} which must be of a valid GPIO pin on the microprocessor. If this operation is successful, a pointer to the implementation is assigned and the function will return non-NULL.
			
Valid GPIO pin addresses for each microprocessor are made up of a specific pin and port and are contained within enumerated lists found in the \textbf{\texttt{hal.h}} file. 			

				\subsection{\textbf{\texttt{set\_mode}} Function}
					\label{ss:Hardware Abstraction Libraries:gpio Module:set_mode Function}
					
					This function enables the user to set the desired directionality of the GPIO pin attached to the instance created. The options available for this function to supply as an argument are either \textbf{\texttt{INPUT}} or \textbf{\texttt{OUTPUT}}.
			
This function returns \textbf{\texttt{0}} always.
			
				\subsection{\textbf{\texttt{write}} Function}
					\label{ss:Hardware Abstraction Libraries:gpio Module:write Function}
			
					The \textbf{\texttt{write}} function gives the ability to output a logic value on a GPIO pin.
			
The function accepts a value of type \textbf{\texttt{gpio\_output\_state}} and consists of one of the following:
			
					\begin{itemize}
					
						\item \textbf{\texttt{O\_LOW}}. Sets the GPIO pin to logic \textbf{\texttt{0}}.

						\item \textbf{\texttt{O\_HIGH}}. Sets the GPIO pin to logic \textbf{\texttt{1}}.

						\item \textbf{\texttt{O\_TOGGLE}}. Toggles the GPIO pin's logic irrespective of its current value.

					\end{itemize}

This function returns \textbf{\texttt{0}} always.

				\subsection{\textbf{\texttt{read}} Function}
					\label{ss:Hardware Abstraction Libraries:gpio Module:read Function}
			
					This function accepts no input arguments but instead returns a value indicating the logic of the GPIO pin it is called with. These values will be one of the following \textbf{\texttt{gpio\_input\_state}} enumerated values:
			
					\begin{itemize}
					
						\item \textbf{\texttt{I\_LOW}}. Logic \textbf{\texttt{0}}.
						
						\item \textbf{\texttt{I\_HIGH}}. Logic \textbf{\texttt{1}}.
						
						\item \textbf{\texttt{I\_ERROR}}. GPIO port out of bounds.
						
					\end{itemize}
			
				\subsection{\textbf{\texttt{attach\_interrupt}} Function}
					\label{ss:Hardware Abstraction Libraries:gpio Module:attach_interrupt Function}
			
					The \textbf{\texttt{attach\_interrupt}} function allows a user to register a function to be executed when an associated event occurs on the implemented GPIO pin.
			
The function accepts a pointer to a user defined ISR function along with a mode that represents a value from the \textbf{\texttt{interrupt\_mode}} enumerated list found in \textbf{\texttt{gpio.h}}. 
			
The function returns one of three values. (\textbf{\texttt{GP\_SUCCESS}}) indicates successful completion of the function, (\textbf{\texttt{GP\_ALREADY\_TAKEN}}) conveys the semaphore for the requested interrupt is already held elsewhere and (\textbf{\texttt{GP\_OUT\_OF\_RANGE}}) implies the pin that interrupt has been attached to does not have an interrupt vector available to it.
			
				\subsection{\textbf{\texttt{disable\_interrupt}} Function}
					\label{ss:Hardware Abstraction Libraries:gpio Module:disable_interrupt Function}
			
					This function removes the association between a registered application ISR and the GPIO event which triggers it. 
			
			\section{\textbf{\texttt{tc}} Module}
				\label{s:Hardware Abstraction Libraries:tc Module}
				
				The \textbf{\texttt{tc}} module provides functionality for the hardware timers and counters. This abstracted control gives the user the ability to initialise, configure and run these elements in a variety of modes.
			
				\subsection{\textbf{\texttt{grab}} Function}
					\label{ss:Hardware Abstraction Libraries:tc Module:grab Function}
					
					The grab function instantiates a timer instance that the user can then use in conjunction with the associated methods in the class to perform the functions they wish.
			
A timer counter number is required to be given to the \textbf{\texttt{grab}} function to proceed with initialisation. This timer counter number is required to be one of an enumerated list found in the \textbf{\texttt{tc\_number}} definition within the \textbf{\texttt{tc.h}} file. 
			
The \textbf{\texttt{grab}} creates a pointer to the implementation requested by the user and returns a timer instance for future use. 
			
				\subsection{\textbf{\texttt{set\_rate}} Function}
					\label{ss:Hardware Abstraction Libraries:tc Module:set_rate Function}
			
					The \textbf{\texttt{set\_rate}} function prescalar and clock source settings for the implemented timer.
			
This function requires the user to provide a \textbf{\texttt{rate}} value which is a custom structure made up both fields to indicate the desired clock source and prescalar for the timer counter. The options for these values are found in the enumerated lists \textbf{\texttt{tc\_clk\_src}} and \textbf{\texttt{tc\_prescalar}} respectively, within the \textbf{\texttt{tc.h}} file.
			
A value of \textbf{\texttt{0}} is returned to indicated success, otherwise if an invalid prescalar setting for the timer chosen is supplied, \textbf{\texttt{-1}} is returned instead.
			
				\subsection{\textbf{\texttt{load\_timer\_value}} Function}
					\label{ss:Hardware Abstraction Libraries:tc Module:load_timer_value Function}
			
					In order to load a specific value into the timer counter register this function should be called. An input value should be provided and an appropriate template employed depending on the size of the input value and the size of the timer counter register.
			
This function returns \textbf{\texttt{0}} always.
			
				\subsection{\textbf{\texttt{get\_timer\_value}} Function}
					\label{ss:Hardware Abstraction Libraries:tc Module:get_timer_value Function}
			
					This function provides the ability to read the current value of the timer counter. No input variables are required but the user must anticapate the size of the returned timer value and apply an appropriate template to suit this.
			
				\subsection{\textbf{\texttt{start}} Function}
					\label{ss:Hardware Abstraction Libraries:tc Module:start Function}
			
					As the name suggests, this function starts the implemented timer.
			
This function returns \textbf{\texttt{0}} if the operation is successful, otherwise it will return \textbf{\texttt{-1}}. 
						
				\subsection{\textbf{\texttt{stop}} Function}
					\label{ss:Hardware Abstraction Libraries:tc Module:stop Function}
			
					The \textbf{\texttt{stop}} function causes the operation of the timer counter to cease.
			
This function returns \textbf{\texttt{0}} always.
			
				\subsection{\textbf{\texttt{enable\_tov\_interrupt}} Function}
					\label{ss:Hardware Abstraction Libraries:tc Module:enable_tov_interrupt Function}
			
					The \textbf{\texttt{enable\_tov\_interrupt}} function facilitates the creation of function execution upon the timer counter overflowing. This is accomplished by providing the function with a pointer to a user-created interrupt service routine (ISR) that will be called at the appropriate time.
			
This function returns \textbf{\texttt{0}} always.
			
				\subsection{\textbf{\texttt{disable\_tov\_interrupt}} Function}
					\label{ss:Hardware Abstraction Libraries:tc Module:disable_tov_interrupt Function}
			
 					Disabling the timer overflow interrupts on a particular timer is catered for by this function. 
			
This function returns \textbf{\texttt{0}} always.
			
				\subsection{\textbf{\texttt{enable\_oc}} Function}
					\label{ss:Hardware Abstraction Libraries:tc Module:enable_oc Function}
			
 					The \textbf{\texttt{enable\_oc}} function allows the user to initiate output compare operation on a timer implementation. The choice of modes are governed by the \textbf{\texttt{tc\_oc\_mode}} enumerated list that is found in the \textbf{\texttt{tc.h}} file. These modes pertain directly to those listed in the ATmega2560's datasheet.
			
This function returns \textbf{\texttt{0}} always.

				\subsection{\textbf{\texttt{enable\_oc\_channel}} Function}
					\label{ss:Hardware Abstraction Libraries:tc Module:enable_oc_channel Function}
			
					The \textbf{\texttt{enable\_oc\_channel}} function controls the initialisation and settings relating to a channel within a timer. 
						
Two input values are provided to the function. These are the desired channel to enable, and the mode to apply to it. Both of these variables are found in the enumerated lists \textbf{\texttt{tc\_oc\_channel}} and \textbf{\texttt{tc\_oc\_channel\_mode}} which are found in the \textbf{\texttt{tc.h}} file.
			
A return value of \textbf{\texttt{0}} indicates successful completion of the function, whilst a value of \textbf{\texttt{-1}} indicates that the GPIO semaphores were unable to be procurred or an invalid mode was specified.
			
				\subsection{\textbf{\texttt{enable\_oc\_interrupt}} Function}
					\label{ss:Hardware Abstraction Libraries:tc Module:enable_oc_interrupt Function}
			
					Attaching or enabling an ISR function to respond to an output compare interrupt is accomplished with this function.
			
The function expects two input values, being the timer channel to which the interrupt is being attached and a function pointer to the user-defined ISR.
			
This function returns \textbf{\texttt{0}} if the ISR was successfully attached and \textbf{\texttt{-1}} if an invalid channel was applied to the implemented timer.
			
				\subsection{\textbf{\texttt{disable\_oc\_interrupt}} Function}
					\label{ss:Hardware Abstraction Libraries:tc Module:disable_oc_interrupt Function}
			
					This function is used for de-associating ISR routines with the associated interrupt.
			
Only one value is expected for the function and that is the channel of the implemented timer to disable.
			
This function returns \textbf{\texttt{0}} if the ISR was successfully disabled and \textbf{\texttt{-1}} if an invalid channel was applied to the implemented timer.
			
				\subsection{\textbf{\texttt{set\_icR}} Function}
					\label{ss:Hardware Abstraction Libraries:tc Module:set_icR Function}
			
					This function allows the input capture register of suitably equipped timers to be manually set for output compare modes where this register is utilised as the timer's \textbf{\texttt{TOP}} value.
			
The function places the provided value in the \textbf{\texttt{ICR}} register and returns \textbf{\texttt{0}} always.
			
				\subsection{\textbf{\texttt{enable\_ic}} Function}
					\label{ss:Hardware Abstraction Libraries:tc Module:enable_ic Function}
			
					This function enables the input capture functionality of a timer when it is provided a channel and mode value. These values represent one of the options defined in the \textbf{\texttt{tc\_ic\_channel}} and \textbf{\texttt{tc\_ic\_mode}} enumerated lists within \textbf{\texttt{tc.h}}.
			
If successful a value of \textbf{\texttt{0}} is returned. Otherwise, a value of \textbf{\texttt{-1}} is returned for an invalid mode or un-available semaphore.
			
				\subsection{\textbf{\texttt{enable\_ic\_interrupt}} Function}
					\label{ss:Hardware Abstraction Libraries:tc Module:enable_ic_interrupt Function}
			
					The \textbf{\texttt{enable\_ic\_interrupt}} function allows the user to register a ISR routine to an input capture channel associated with the implemented timer (when one is available).
			
The input capture channel is provided by way of a channel number (defined in the \textbf{\texttt{tc\_ic\_channel}} enumerated list) as an input value, along with a function pointer to the user's ISR.			
			
The function returns \textbf{\texttt{0}} for success and \textbf{\texttt{-1}} to indicate that input capture functionality is not available on the implemented timer.	
			
				\subsection{\textbf{\texttt{disable\_ic\_interrupt}} Function}
					\label{ss:Hardware Abstraction Libraries:tc Module:disable_ic_interrupt Function}
			
					In order to disable an interrupt that is attached to an input capture event, this function may be used. It once again accepts the channel for which the interrupt should be disabled as an input value.
 			
 If the implemented timer does not feature input capture functionality, this function will return a value of \textbf{\texttt{-1}}, otherwise \textbf{\texttt{0}} is returned.
			
				\subsection{\textbf{\texttt{get\_icR}} Function}
					\label{ss:Hardware Abstraction Libraries:tc Module:get_icR_interrupt Function}
			
					When provided with a valid input capture channel number and an appropriate data type template is provided in the function call, this function will return the contents of the \textbf{\texttt{ICR}} register.	
			
				\subsection{\textbf{\texttt{vacate}} Function}
					\label{ss:Hardware Abstraction Libraries:tc Module:vacate Function}
			
					This function may be called when the timer implementation is to be reset, or else it is called by default when the implementation goes out of scope.
			
			\section{\textbf{\texttt{watchdog}} Module}
				\label{s:Hardware Abstraction Libraries:watchdog Module}
			
				The \textbf{\texttt{watchdog}} module provides abstracted use of the system watchdog timer. It allows a user to enable, pat and disable the watchdog timer easily.

				\subsection{\textbf{\texttt{enable}} Function}
					\label{ss:Hardware Abstraction Libraries:watchdog Module:enable Function}
			
					To enable a watchdog timer, the user simply calls this function and provides it one of a number of pre-defined time out periods. These periods are defined in \textbf{\texttt{watchdog.h}}.
						
				\subsection{\textbf{\texttt{pat}} Function}
					\label{ss:Hardware Abstraction Libraries:watchdog Module:pat Function}
			
					In order to prevent a watchdog initiated reset, the {\textbf{\texttt{pat}}} resets the implemented watchdog.
			
				\subsection{\textbf{\texttt{disable}} Function}
					\label{ss:Hardware Abstraction Libraries:watchdog Module:disable Function}
			
					This function disables the watchdog timer in use.
			
			\section{\textbf{\texttt{usart}} Module}
				\label{s:Hardware Abstraction Libraries:usart Module}
			
				This module provides functionality for implementing, initialising and using USART hardware.
			
				\subsection{\textbf{\texttt{grab}} Function}
					\label{ss:Hardware Abstraction Libraries:usart Module:grab Function}
			
					This function may be used for creating a \textbf{\texttt{usart}} isntance with which to initialise and use. Only one variable is expected as input to these function, namely a \textbf{\texttt{usartNumber}} value which is of the enumerated list \textbf{\texttt{usart\_number}} and found in \textbf{\texttt{usart.h}}.
						
If the \textbf{\texttt{grab}} function is successful, a link to the requested implementation is created and a \textbf{\texttt{usart}} instance returned, otherwise \textbf{\texttt{NULL}} is returned.
			
				\subsection{\textbf{\texttt{set\_mode}} Function}
					\label{ss:Hardware Abstraction Libraries:usart Module:set_modeFunction}	
			
					The USART modules are capable of operating in multiple modes. This function allows the operation to be set and the options possible are listed in the \textbf{\texttt{usart\_setup\_mode}} list contained in \textbf{\texttt{usart.h}}.
			
When called, this function disables global interrupts to allow for un-disturbed access to the control registers. These registers are then accessed and the settings applied as dictated by the specified mode.
			
For modes such as \textbf{\texttt{MASTER\_SPI}} that require a GPIO pin whose directionality is not automatically set through hardware, this function is also responsible for this process.
			
				\subsection{\textbf{\texttt{set\_frame}} Function}
					\label{ss:Hardware Abstraction Libraries:usart Module:set_frameFunction}
			
					The ability to define the serial format required for communication is extremely important. This function caters for this by allowing the user to specify their desired settings for packet size, parity type and number of stop bits. The parity type should be one of the options listed in the \textbf{\texttt{parity\_option}} enumerated list within \textbf{\texttt{usart.h}}. The frame size should be between five and eight bits whilst the user should specify either one or two stop bits.
			
The function returns \textbf{\texttt{0}} if the function completes the task successfully, otherwise \textbf{\texttt{-1}} is returned to indicate an invalid option was specified.
			
				\subsection{\textbf{\texttt{set\_baud\_rate}} Function}
					\label{ss:Hardware Abstraction Libraries:usart Module:set_baud_rateFunction}
			
					The baud rate is another important initialisation setting for the serial communication. The user may specify whatever baud rate they wish.
					
This function returns \textbf{\texttt{0}} always.

				\subsection{\textbf{\texttt{double\_usart\_speed}} Function}
					\label{ss:Hardware Abstraction Libraries:usart Module:double_usart_speedFunction}
			
					Doubling the USART speed is an option that is only pertinent when the USART module has been configured in asynchronous operation. This function accepts a boolean value to allow the user to either enable or disable such operation depending on the value being true or false respectively.
			
The function returns \textbf{\texttt{0}} always.

				\subsection{\textbf{\texttt{buffer\_is\_available}} Function}
					\label{ss:Hardware Abstraction Libraries:usart Module:buffer_is_availableFunction}
			
					This function returns a boolean value to indicate whether the USART data register buffer is empty or not at the time of checking. A true value indicates that the buffer is available, whilst false indicates otherwise.
			
				\subsection{\textbf{\texttt{transmit\_byte}} Function}
					\label{ss:Hardware Abstraction Libraries:usart Module:transmit_byteFunction}
			
					This function allows the user to transmit a single byte value via the established USART connection by copying it to the data register buffer.
							
The function returns \textbf{\texttt{0}} always.
			
				\subsection{\textbf{\texttt{transmit\_string}} Function}
					\label{ss:Hardware Abstraction Libraries:usart Module:transmit_stringFunction}
			
					This function has the capability to transmit a NULL-terminated string (or array) via USART. The user should provide a pointer to this string which is then transmitted in a byte-by-byte fashion. Note that this function will 'block' the processor until the transmission is complete.
			
The function returns \textbf{\texttt{0}} always.
			
				\subsection{\textbf{\texttt{transmit\_array}} Function}
					\label{ss:Hardware Abstraction Libraries:usart Module:transmit_arrayFunction}
			
					To transfer an array of arbitary size and type, this function may be employed. It has the ability to transmit such data in a byte-by-byte fashion until the routine is complete.
			
A pointer cast to the array of data that has been cast to a fixed-width byte datatype is required, as is the number of elements to transmit.
			
This function blocks until it has completed. A value of \textbf{\texttt{0}} is always returned. 
			
				\subsection{\textbf{\texttt{transmission\_complete}} Function}
					\label{ss:Hardware Abstraction Libraries:usart Module:transmission_completeFunction}
			
					This function returns a boolean to indicate whether there is new data that has not been transmitted in the buffer of the USART channel implemented is empty or not. The value returned is true if there is no new data and false otherwise.
			
				\subsection{\textbf{\texttt{receive\_complete}} Function}
					\label{ss:Hardware Abstraction Libraries:usart Module:receive_completeFunction}
			
					This function returns a boolean to indicate whether the data buffer of the USART channel implemented contains new unread data. The value returned is true if this is so and false otherwise.
			
				\subsection{\textbf{\texttt{receive\_byte}} Function}
					\label{ss:Hardware Abstraction Libraries:usart Module:receive_byteFunction}
			
					In order to receive data via USART, the data register buffer must be read when new unread data is present. This function checks to ensure there is in fact unread data and returns the contents of the buffer if there is.
			
				\subsection{\textbf{\texttt{enable\_interrupt}} Function}
					\label{ss:Hardware Abstraction Libraries:usart Module:enable_interruptFunction}	
			
					A user defined ISR may be attached to a number of interrupt vectors associated with the USART hardware. These interrupt vectors or types are contained in the \textbf{\texttt{usart\_interrupt\_types}} enumerated list of the \textbf{\texttt{usart.h}} file.	Broadly speaking, these interrupts can occur when a USART transmission has been completed, when new data has been received, and when the data register buffer is empty.
			
				\subsection{\textbf{\texttt{disable\_byte}} Function}
					\label{ss:Hardware Abstraction Libraries:usart Module:disable_byteFunction}
			
					Any interrupt functions associated with a USART interrupt signal can be disabled by calling this function.
			
The user must provide the one of the enumerated interrupt types available for the USART to disable a specific interrupt. 
			
				\subsection{\textbf{\texttt{usart\_error}} Function}
					\label{ss:Hardware Abstraction Libraries:usart Module:usart_errorFunction}
			
					Communication via USART may produce cases where the communicated packet is invalid or corrupted. This function provides the ability to check any errors on the USART connection.
			
If any of these errors exist, it will return an indicating flag, as listed in the \textbf{\texttt{usart\_error\_types}} list located in \textbf{\texttt{usart.h}}, for the first error found; or else a flag indicating no error if none exists.
			
				\subsection{\textbf{\texttt{vacate}} Function}
					\label{ss:Hardware Abstraction Libraries:usart Module:vacateFunction}
			
					The \textbf{\texttt{vacate}} function may be called when the USART instance is no longer required; or else when it goes out of scope.
			
This function vacates the semaphores that were procured upon initialisation for the required GPIO pins and sets all the interrupt function pointers associated with the instance to NULL.

				\subsection{Master SPI Mode Functions}
					\label{ss:Hardware Abstraction Libraries:usart Module:Master SPI Mode Functions}
			
					The USART hardware on some devices has the ability to operate in SPI mode, emulating the protocol of this communication bus. This often has some advantages over the conventional SPI mode including the double buffered transmitter (where the SPI peripheral proper is unbuffered and DMA is unavailable).
			
Access to the Master SPI Mode (MSPIM) is via the \textbf{\texttt{set\_mode}} function (see: \S\ref{sss:HALusartset_modeFunction}).
				
					\subsubsection{\textbf{\texttt{set\_spi\_mode}} Function}
						\label{sss:Hardware Abstraction Libraries:usart Module:Master SPI Mode Functions:set_spi_mode Function}
			
						This function allows the user to set the desired clock phase and polarity settings for MSPIM. The options are contained in the enumerated list \textbf{\texttt{mspim\_mode}} (found in \textbf{\texttt{usart.h}} and relate directly to those modes specified for MSPIM in the ATmega2560 datasheet.
			
These modes are applied only if the USART hardware has been previously initialised to MSPIM. If this is not the case, a value of \textbf{\texttt{-1}} is returned. Otherwise, upon successful completion of the function a value of \textbf{\texttt{0}} is returned.
			
					\subsubsection{\textbf{\texttt{set\_bit\_order}} Function}
						\label{sss:Hardware Abstraction Libraries:usart Module:Master SPI Mode Functions:set_bit_order Function}
			
						This function allows the user to set the desired bit order of the MSPIM connection. The options are one of \textbf{\texttt{MSPIM\_MSB\_FIRST}}, or \textbf{\texttt{MSPIM\_LSB\_FIRST}} (defined in \textbf{\texttt{usart.h}}), which relate to either setting the most or the least significant bit first. Note, this function will only work if the USART hardware has been previously initialised to MSPIM. If this is not the case, a value of \textbf{\texttt{-1}} is returned. 
			
A value of \textbf{\texttt{0}} is returned if the function is successful.
			
					\subsubsection{\textbf{\texttt{spi\_transfer\_byte}} Function}
						\label{sss:Hardware Abstraction Libraries:usart Module:Master SPI Mode Functions:spi_transfer_byte Function}
			
						When in MSPIM mode, the transfer of a single byte can be achieved by this function. A single byte is provided as an input argument and the function returns the byte it receives in the transfer process, or else a value of \textbf{\texttt{0}} if the USART hardware has not been configured in MSPIM.
	
Note that this function blocks the resources of the microprocessor until the function completes.
			
					\subsubsection{\textbf{\texttt{spi\_transfer\_array}} Function}
						\label{sss:Hardware Abstraction Libraries:usart Module:Master SPI Mode Functions:spi_transfer_array Function}
			
						An array of arbitary size and type can be received and transmitted in MSPIM via this function. A pointer to both the array to be transmitted and a location where the received data may be returned is required as well as the number of elements to transfer.
			
Note that this function blocks the resources of the microprocessor until the function completes.

	% THEN COMES ANY SUPPORTING MATERIAL.

	% Switch to 'appendices' mode.  Alphabetic chapter headings.
	\appendix

\end{document}
