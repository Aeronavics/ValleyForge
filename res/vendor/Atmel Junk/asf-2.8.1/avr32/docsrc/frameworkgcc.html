<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
   <head>
      <link rel="stylesheet" type="text/css" href="./AVR32_ns.css">
   </head>
	 <body>
 <div id="container">
 <div id="header"></div>
 <div id="wrapper">
 <div id="content">

<p align="left" class="whs2"><a href="../readme.html"<font color="red"></font>Back to main page</a></p>
<h1 align="center" class="whs1">AVR Software Framework: UC3 GCC Projects<br>
</h1>

<p align="center" class="whs2">Copyright &copy; 2007 Atmel Corporation</p>



<p>&nbsp;</p> 
<h2>Introduction </h2>
<p>To use the GCC projects, you need to install the <a href="http://www.atmel.com/dyn/products/tools_card.asp?tool_id=4118"> AVR32 GNU toolchain </a> first.</p>
<!-- UC3A_START -->
<p>Let's take the example of the GPIO driver module. Go To /drivers/GPIO/PERIPHERAL_BUS_EXAMPLE/
<li>AT32UC3A0512_EVK1100/GCC folder contains a Makefile, a configuration file (config.mk) and a configuration file for the GDB debugger for EVK1100.  </li>
<li>AT32UC3A0512_EVK1105/GCC folder contains a Makefile, a configuration file (config.mk) and a configuration file for the GDB debugger for EVK1105.  </p>
<li>AT32UC3A3256_EVK1104/GCC folder contains a Makefile, a configuration file (config.mk) and a configuration file for the GDB debugger for EVK1104.  </p>
<li>AT32UC3B0256_EVK1101/GCC folder contains a Makefile, a configuration file (config.mk) and a configuration file for the GDB debugger for EVK1101.  </li>
<li>AT32UC3C0512C_REVC_UC3C_EK/GCC folder contains a Makefile, a configuration file (config.mk) and a configuration file for the GDB debugger for UC3C_EK.  </p>
<li>AT32UC3L064_STK600-RCUC3L0/GCC folder contains a Makefile, a configuration file (config.mk) and a configuration file for the GDB debugger for STK600-RCUC3L0.</p>



<p>&nbsp;</p> 
<h2>Makefile </h2>
<p>The GPIO example <a href="./../drivers/gpio/peripheral_bus_example/at32uc3a0512_evk1100/gcc/Makefile">Makefile</a> Makefile is a generic Makefile for avr32-gcc.</p>

The Makefile comes with pre-built Make goals:
</p>
  <li> [all]:                       Default goal: build the project.
  </li><li> clean:                  Clean up the project.
  </li><li> rebuild:                Rebuild the project.
  </li><li> ccversion:              Display CC version information.
  </li><li> cppfiles  file.i:       Generate preprocessed files from C source files.
  </li><li> asfiles   file.x:       Generate preprocessed assembler files from C and assembler source files.
  </li><li> objfiles  file.o:       Generate object files from C and assembler source files.
  </li><li> a         file.a:       (Archive) Create an archive output file from object files.
  </li><li> elf       file.elf:     (Link) Create ELF output file from object files.
  </li><li> lss       file.lss:     Create extended listing from target output file.
  </li><li> sym       file.sym:     Create symbol table from target output file.
  </li><li> hex       file.hex:     Create Intel HEX image from ELF output file.
  </li><li> bin       file.bin:     Create binary image from ELF output file.
  </li><li> sizes:                  Display target size information.
  </li><li> isp:                    Use ISP instead of JTAGICE mkII when programming.
  </li><li> cpuinfo:                Get CPU information.
  </li><li> halt:                   Stop CPU execution.
  </li><li> chiperase:              Perform a JTAG Chip Erase command.
  </li><li> erase:                  Perform a flash chip erase.
  </li><li> program:                Program MCU memory from ELF output file.
  </li><li> secureflash:            Protect chip by setting security bit.
  </li><li> reset:                  Reset MCU.
  </li><li> debug:                  Open a debug connection with the MCU.
  </li><li> run:                    Start CPU execution.
  </li><li> readregs:               Read CPU registers.
  </li><li> doc:                    Build the documentation.
  </li><li> cleandoc:               Clean up the documentation.
  </li><li> rebuilddoc:             Rebuild the documentation.
  </li><li> verbose:                Display main executed commands.
  </li></p>
<p>&nbsp;</p> 

<p>To program the target and run the program, you can type the following command from cygwin if you want to use JTAGICE mkII:
</p>
<pre> make program run
</pre>
<p>Or the following command if you want to use the bootloader:
</p>
<pre> make isp program run
</pre>

<h2>config.mk: Configuration options for the Makefile. </h2>


<p>Check the GPIO example <a href="./../drivers/gpio/peripheral_bus_example/at32uc3a0512_evk1100/gcc/config.mk">config.mk</a> file for Makefile configuration.</p>

This config.mk defines configurations like target, include path, source files and compiler optimization:
<p>&nbsp;</p>

<li> <b>Base paths</b>: define the path of the framework main directories </p>
<pre>
PRJ_PATH = ../../../../..
APPS_PATH = $(PRJ_PATH)/applications
BRDS_PATH = $(PRJ_PATH)/boards
COMP_PATH = $(PRJ_PATH)/components
DRVR_PATH = $(PRJ_PATH)/drivers
SERV_PATH = $(PRJ_PATH)/services
UTIL_PATH = $(PRJ_PATH)/utils
</pre>

<li> <b>GCC Architecture and parts</b>: the AVR32 <a href="http://www.atmel.com/dyn/resources/prod_documents/doc32002.pdf"> UC </a> architecture and part number. </li>
<pre>
<!-- UC3A_START -->
ARCH = ucr2
PART = uc3a0512
<!-- UC3A_END -->
<!-- UC3B_START -->
ARCH = ucr1
PART = uc3b0256
<!-- UC3B_END -->
<!-- UC3A3_START -->
ARCH = ucr2
PART = uc3a3256
<!-- UC3A3_END -->
<!-- UC3L_START -->
ARCH = ucr3
PART = uc3l064
<!-- UC3L_END -->
<!-- UC3L_START -->
ARCH = ucr3
PART = uc3c0512CRevC
<!-- UC3L_END -->
</pre>


<li> <b>Device/Platform/Board</b> include path: the /boards/board.h file use the BOARD define to select the correct board definitions.
<pre>
PLATFORM_INC_PATH = \
  $(BRDS_PATH)/
</pre>

<li> <b>Definitions</b>: Preprocessor definitions. Note that the <b><i>BOARD</i></b> preprocessor define must be defined to identify the target board.</li>
<table border="1"> 
  <tr>
  <th>EVK1100</th>
  <td>
    <pre>DEFS = -D BOARD=EVK1100 -D _ASSERT_ENABLE_</pre>
  </td>
  </tr>
  <tr>
  <th>EVK1101</th>
  <td>
    <pre>DEFS = -D BOARD=EVK1101 -D _ASSERT_ENABLE_</pre>
  </td>
  </tr>
  <tr>
  <th>EVK1104</th>
  <td>
    <pre>DEFS = -D BOARD=EVK1104 -D _ASSERT_ENABLE_</pre>
  </td>
  </tr>
  <tr>
  <th>EVK1105</th>
  <td>
    <pre>DEFS = -D BOARD=EVK1105 -D _ASSERT_ENABLE_</pre>
  </td>  
  </tr>
  <tr>
  <th>STK600/RCUC3L0</th>
  <td>
    <pre>DEFS = -D BOARD=STK600_RCUC3L0 -D _ASSERT_ENABLE_</pre>
  </td>
  </tr>
  <tr>
  <th>UC3C_EK</th>
  <td>
    <pre>DEFS = -D BOARD=UC3C_EK -D _ASSERT_ENABLE_</pre>
  </td>
  </tr>
</table>

<li> <b>Include paths</b>: all used modules includes path.</p>
<i>utils/PREPROCESSOR</i> is required when the UTILS/compiler.h file is used. This is the case for all examples provided in this Software framework.</p>
<i>services/USB/CLASS/DFU/EXAMPLES/ISP/BOOT</i> may be useful when linking with the bootloader or its trampoline.</p>
<pre>
INC_PATH = \
  $(UTIL_PATH)/ \
  $(UTIL_PATH)/PREPROCESSOR/ \
  $(SERV_PATH)/USB/CLASS/DFU/EXAMPLES/ISP/BOOT/ \
  $(DRVR_PATH)/GPIO/
</pre>

<li> <b>C and Assembler source files</b> :
<i>gpio.c</i> and <i>gpio_peripheral_bus_example.c</i> respectively are the GPIO driver and the example application.</p>
<i>intc.c</i> and <i>exception.S</i> files are used to manage exceptions and handler addresses for processor events.</p>
<i>crt0.S</i> is the C runtime startup which gets executed just after the reset vector and before the main() C function: its main mission is to initialize critical registers (example: the stack pointer) and memory. If it is not provided, unlike here, GCC will use its own start entry point depending on ARCH value.</p>
<i>trampoline.S</i> is the code positionned at the reset vector and launching the C runtime startup in crt0.S by jumping over the memory area normally dedicated to the bootloader.</p>

<pre>
CSRCS = \
  $(DRVR_PATH)/INTC/intc.c \
  $(DRVR_PATH)/GPIO/gpio.c \
  ../../gpio_peripheral_bus_example.c

ASSRCS = \
  $(SERV_PATH)/USB/CLASS/DFU/EXAMPLES/ISP/BOOT/trampoline.S \
  $(UTIL_PATH)/STARTUP_FILES/GCC/crt0.S \
  $(DRVR_PATH)/INTC/exception.S
</pre>

For UC3C0512CRevC devices :
<pre>
ASSRCS = \
  $(SERV_PATH)/USB/CLASS/DFU/EXAMPLES/ISP/BOOT/trampoline.S \
  $(UTIL_PATH)/STARTUP_FILES/GCC/crt0.S \
  $(DRVR_PATH)/INTC/exception.S
</pre>


<li> <b>Libraries to link with the project</b> if any: e.g., add `m' to link the math library libm.a.
<pre>
LIBS =
</pre>
<!-- UC3A_START -->
<li> <b>Linker script</b> If nothing is specified, GCC will use its default linker script based on the ARCH & PART definition (described here above) instead.</p>


<table border="2"> 
  <tr>
  <th>UC3A0512</th>
  <td >the GPIO example links to the Software Framework UC3A0512 linker script in <i>/utils/LINKER_SCRIPTS/AT32UC3A/0512/GCC/</i>.
   <pre>
    LINKER_SCRIPT = $(UTIL_PATH)/LINKER_SCRIPTS/AT32UC3A/0512/GCC/link_uc3a0512.lds
  </pre></td>
  </tr>
  
  <tr>
  <th>UC3A3256</th>
  <td >the GPIO example links to the Software Framework UC3A3256 linker script in <i>/utils/LINKER_SCRIPTS/AT32UC3A3/256/GCC/</i>.
  <pre>
    LINKER_SCRIPT = $(UTIL_PATH)/LINKER_SCRIPTS/AT32UC3A3/256/GCC/link_uc3a3256.lds
  </pre></td>  
  </tr>
  
  <tr>
  <th>UC3B0256</th>
  <td >the GPIO example links to the Software Framework UC3B0256 linker script in <i>/utils/LINKER_SCRIPTS/AT32UC3B/0256/GCC/</i>.
   <pre>
    LINKER_SCRIPT = $(UTIL_PATH)/LINKER_SCRIPTS/AT32UC3B/0256/GCC/link_uc3b0256.lds
  </pre></td>  
  </tr>
  

  
  <tr>
  <th>UC3L064</th>
  <td >the GPIO example links to the Software Framework UC3L064 linker script in <i>/utils/LINKER_SCRIPTS/AT32UC3L/064/GCC/</i>.
  <pre>
    LINKER_SCRIPT = $(UTIL_PATH)/LINKER_SCRIPTS/AT32UC3L/064/GCC/link_uc3l064.lds
  </pre></td>  
  </tr>
  
  <tr>
  <th>UC3C0512C</th>
  <td >the GPIO example links to the Software Framework UC3L064 linker script in <i>/utils/LINKER_SCRIPTS/AT32UC3C/0512C/GCC/</i>.
  <pre>
    LINKER_SCRIPT = $(UTIL_PATH)/LINKER_SCRIPTS/AT32UC3C/0512C/GCC/link_uc3c0512c.lds
  </pre></td>  
  </tr>
  
</table>



<li> <b>Compiler optimization</b>: [-O[0|1|2|3|s]]...For further details, refer to the chapter "GCC Command Options" of the GCC manual.
<pre>
OPTIMIZATION = -O0 -ffunction-sections -fdata-sections
</pre>


<li> <b>Extra flags to be used by the GCC linker</b>: <b><i>-nostdlib</i></b> tells the linker to not link with the C standard library. <i>crt0.S</i> and exception management files (<i>intc.c</i> and <i>exception.S</i>) will be used instead (cf. above). <b><i>-nostartfiles</i></b> can be used instead to tell the linker to not use the default crt0.o GNU toolchain startup file without preventing from linking standard C functions.</p>
The linker <b><i>--gc-sections</i></b> option makes sense when used with the GCC compiler optimization options <b><i>-ffunction-sections</i></b> or <b><i>-fdata-sections</i></b> : it is destined to optimize the link step in terms of generated size (unused sections won't be linked).</li>
<pre>
LD_EXTRA_FLAGS = -Wl,--gc-sections -nostdlib
</pre>

<h2>gdb_cmdfile.txt: configuration file for the avr32-gdb program </h2>
<p>Usage: you can type from your favorite terminal:
</p>
<pre> avr32-gdb -x gdb_cmdfile.txt
</pre>
or
</p>
<pre> ddd --debugger avr32-gdb -x gdb_cmdfile.txt
</pre>

<p>&nbsp;</p> 
<h2> Embedded Development Quick Start</h2>
GCC <a href="./tutorials/gcc/embedded_development_quick_start.htm"> quick start</a> with GPIO example: how to deploy the GPIO example on target in 5 steps.

<p>&nbsp;</p>
<h2>FAQ</h2>
In the <a href="./faq.html">FAQ page</a>, you will find a list of <b>Frequently Asked Questions</b> related to the Software Framework.
<p>&nbsp;</p>

<hr align="center" width="50%" class="whs4">

</div></div>
   </body>
</html>
