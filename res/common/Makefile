#	Copyright (C) 2013  Unison Networks Ltd
#
#	This program is free software: you can redistribute it and/or modify
#	it under the terms of the GNU General Public License as published by
#	the Free Software Foundation, either version 3 of the License, or
#	(at your option) any later version.
#
#	This program is distributed in the hope that it will be useful,
#	but WITHOUT ANY WARRANTY; without even the implied warranty of
#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#	GNU General Public License for more details.
#
#	You should have received a copy of the GNU General Public License
#	along with this program.  If not, see <http://www.gnu.org/licenses/>.

#
# GENERIC MAKEFILE WITH DEPENDENCY CALCULATION.
#
#	Author:		Edwin Hayes
#
#	Created:	2nd April 2013
#

# VARIABLES.

# Make Configuration Details.
SHELL=/bin/bash # Need to use bash, since we use some non-posix features.

# Component & Filename Details.
COMPONENT=BUILD_INSERTS_COMPONENT_HERE
EXECUTABLE=BUILD_INSERTS_EXECUTABLE_HERE

# Executables.
CC=BUILD_INSERTS_C_COMPILER_HERE # The C compiler to use.
PC=BUILD_INSERTS_P_COMPILER_HERE # The C++ compiler to use.
AS=BUILD_INSERTS_ASSEMBLER_HERE # The assembler to use.
LD=BUILD_INSERTS_LINKER_HERE # The linker to use.
OBJDUMP=BUILD_INSERTS_OBJDUMP_HERE # The object-dump (binary manipulator) to use.
OBJCOPY=BUILD_INSERTS_OBJCOPY_HERE # The object-copy (binary manipulator) to use.

# Flags.
CFLAGS=BUILD_INSERTS_CFLAGS_HERE # The C compiler flags to apply.
PFLAGS=BUILD_INSERTS_PFLAGS_HERE # The C++ compiler flags to apply.
AFLAGS=BUILD_INSERTS_AFLAGS_HERE # The assembler flags to apply.
LFLAGS=BUILD_INSERTS_LFLAGS_HERE # The linker flags to apply.

# FUNCTIONS.

#	This function parses a dependency file (referenced by $1) which will contain header file references (generated by the compiler's '-M' option) and tries to add
#	required sources file dependencies.  In this implementation, we assume that if a required header file has a matching source file in the same folder, then that 
#	will probably be an object dependency (and hence the source should be compiled).
define detect_source_dependencies
	while read -a line; do 									\
		for word in "$${line[@]}"; do 							\
			if [[ $$word == *".h" && $$word != "$*.h" ]]; then			\
				if [ -f "$${word/%.h/.c}" ]; then 				\
					sed -i "s^$$word^$$word $${word/%.h/.o}^g" $(1);	\
				fi;								\
			fi;									\
		done;										\
	done < $(1);										\
	while read -a line; do									\
		for word in "$${line[@]}"; do							\
			if [[ $$word == *".hpp" && $$word != "$*.hpp" ]]; then			\
				if [ -f "$${word/%.hpp/.cpp}" ]; then				\
					sed -i "s^$$word^$$word $${word/%.hpp/.o}^g" $(1);	\
				fi;								\
			fi;									\
		done;										\
	done < $(1);										\
	while read -a line; do									\
		for word in "$${line[@]}"; do							\
			if [[ $$word == *".hs" && $$word != "$*.hs" ]]; then			\
				if [ -f "$${word/%.hs/.s}" ]; then				\
					sed -i "s^$$word^$$word $${word/%.hs/.o}^g" $(1);	\
				fi;								\
			fi;									\
		done;										\
	done < $(1)
endef

#	This function records all of the object file dependencies for a particular object file (referenced by $2), based on a matching dependency
#	file (referenced by $1).  This allows for easily establishing which files to link to produce an executable for a particular object file,
#	without recursing through the dependency tree all over again.
define record_link_dependencies
	echo $(2).o > $(2).ld;									\
	while read -a line; do									\
		for word in $${line[@]}; do							\
			if [[ $${word} != *: ]]; then						\
				if [[ $${word} == *.o ]]; then					\
					cat $${word/%.o/.ld} >> $(2).ld;			\
				fi;								\
			fi;									\
		done;										\
	done < $(1)
endef

# PSEUDO-TARGETS

# All the pseudo-targets are phony: they don't correspond with real files.
.PHONY: all main

all: main

main: $(EXECUTABLE)

# TARGETS.

#	EXECUTABLE FILES.

%:
	@echo "******** Linking $@ from Object Files. ********"
	$(LD) $(LFLAGS) -o $@ $(shell cat $@.ld)

#	OBJECT FILES.

# Object from C.
%.o : %.c
	@echo "******** Compiling $@. ********"
	$(CC) $(CFLAGS) -c $< -o $@

# Object from C++.
%.o : %.cpp
	@echo "******** Compiling $@. ********"
	$(PC) $(PFLAGS) -c $< -o $@

# Object from assembly.
%.o : %.s
	@echo "******** Compiling $@. ********"
	$(AS) $(AFLAGS) $< -o $@

#	ASSEMBLY FILES.

# Assembly from C.
%.s: %.c
	@echo "******** Assembling $@. ********"
	$(CC) $(CFLAGS) -s $< -o $@

# Assembly from CPP.
%.s: %.cpp
	@echo "******** Assembling $@. ********"
	$(CC) $(CFLAGS) -s $< -o $@

# DEPENDENCY TARGETS.

# Header file dependencies are calculated directly by the compiler, they are easy.  Object file dependencies are more complicated; they are 
# calculated by a separate function.

# Dependency from C.
%.dc: %.c
	@echo "******** Calculating dependencies for $*. ********"
	@${CC} ${CFLAGS} -MM $^ > $@
	@$(call detect_source_dependencies,$@)
	@cat $@
	@$(call record_link_dependencies,$@, $*)
	@cat ${patsubst %.dc, %.ld, $@}

# Dependency from C++.
%.dcpp: %.cpp
	@echo "******** Calculating dependencies for $*. ********"
	@${PC} ${PFLAGS} -MM $^ > $@
	@$(call detect_source_dependencies,$@)
	@cat $@
	@$(call record_link_dependencies,$@, $*)
	@cat ${patsubst %.dcpp, %.ld, $@}

# Dependency from assembly.
%.ds: %.s
	@echo "******** Calculating dependencies for $*. ********"
	@${PC} ${PFLAGS} -MM $^ > $@
	@$(call detect_source_dependencies,$@)
	@cat $@
	@$(call record_link_dependencies,$@, $*)
	@cat ${patsubst %.ds, %.ld, $@}

# The dependencies for the target output file are created by assuming that the target output file requires some object file which carries the same
# name as the executable being compiled.  It's assumed that from there, all other dependencies can be discovered from the include chain (this now
# includes assembler files, which will need header files so they are discovered).

# Dependencies of executable.
${EXECUTABLE}.d:
	@echo "******** Calculating executable dependencies. ********"
	@# Work out what the main file is going to be, so we can build the output file.
	@echo -e "Assuming executable ${EXECUTABLE} will depend upon ${EXECUTABLE}.o"
	@echo -e "${EXECUTABLE}: ${EXECUTABLE}.o\n" >> ${EXECUTABLE}.d

# IMPORT EXTERNAL DEPENDENCIES.

# Dependencies are calculated for all the source files, even if they might not be needed, because there isn't an option to go back and include
# additional rules later, so we have to include all the rules we might possibly need right from the start.

# Include dependencies for C files.
-include ${patsubst %.c, %.dc, ${wildcard *.c}}
-include ${patsubst %.c, %.dc, ${wildcard **/*.c}}

# Include dependencies for C++ files.
-include ${patsubst %.cpp, %.dcpp, ${wildcard *.cpp}}
-include ${patsubst %.cpp, %.dcpp, ${wildcard **/*.cpp}}

# Include dependencies for assembly files.
-include ${patsubst %.s, %.ds, ${wildcard *.s}}
-include ${patsubst %.s, %.ds, ${wildcard **/*.s}}

# Dependencies also need to be calculated for the executable as a whole, so that we actually have some rules which create us the desired output
# file, using the appropriate source files.

# Include dependencies for executable main.
-include ${EXECUTABLE}.d


