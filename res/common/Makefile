#	Copyright (C) 2013  Unison Networks Ltd
#
#	This program is free software: you can redistribute it and/or modify
#	it under the terms of the GNU General Public License as published by
#	the Free Software Foundation, either version 3 of the License, or
#	(at your option) any later version.
#
#	This program is distributed in the hope that it will be useful,
#	but WITHOUT ANY WARRANTY; without even the implied warranty of
#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#	GNU General Public License for more details.
#
#	You should have received a copy of the GNU General Public License
#	along with this program.  If not, see <http://www.gnu.org/licenses/>.

#
# GENERIC MAKEFILE WITH DEPENDENCY CALCULATION.
#
#	Author:		Edwin Hayes
#
#	Created:	2nd April 2013
#

# VARIABLES.

# Make Configuration Details.
SHELL=/bin/bash # Need to use bash, since we use some non-posix features.
	# Disable implicit rules, since they will screw dependency detection up.
.SUFFIXES:
DEPENDENCY_LINES_TO_TRUNCATE=6

# Shell colours.
NO_COLOUR=\033[0m
BOLD_WHITE=\033[1;37m

# Component & Filename Details.
COMPONENT=BUILD_INSERTS_COMPONENT_HERE
EXECUTABLE=BUILD_INSERTS_EXECUTABLE_HERE
LOOSE_OBJECTS=BUILD_INSERTS_LOOSE_OBJECTS_HERE

# Executables.
CC=BUILD_INSERTS_C_COMPILER_HERE # The C compiler to use.
PC=BUILD_INSERTS_P_COMPILER_HERE # The C++ compiler to use.
AS=BUILD_INSERTS_ASSEMBLER_HERE # The assembler to use.
LD=BUILD_INSERTS_LINKER_HERE # The linker to use.
OBJDUMP=BUILD_INSERTS_OBJDUMP_HERE # The object-dump (binary manipulator) to use.
OBJCOPY=BUILD_INSERTS_OBJCOPY_HERE # The object-copy (binary manipulator) to use.

# Flags.
CFLAGS=BUILD_INSERTS_CFLAGS_HERE # The C compiler flags to apply.
PFLAGS=BUILD_INSERTS_PFLAGS_HERE # The C++ compiler flags to apply.
AFLAGS=BUILD_INSERTS_AFLAGS_HERE # The assembler flags to apply.
LFLAGS=BUILD_INSERTS_LFLAGS_HERE # The linker flags to apply.

# FUNCTIONS.

#	This function parses a dependency file (referenced by $1) which will contain header file references (generated by the compiler's '-M' option) and tries to add
#	required sources file dependencies.  In this implementation, we assume that if a required header file has a matching source file in the same folder, then that 
#	will probably be an object dependency (and hence the source should be compiled).
define detect_source_dependencies
	while read -a line -r; do								\
		for word in "$${line[@]}"; do 							\
			if [[ $$word == "\\" ]]; then						\
				continue;							\
			elif [[ $$word == *".h" && $$word != "$*.h" ]]; then			\
				if [ -f "$${word/%.h/.c}" ]; then 				\
					real=$$(readlink -m $$word);				\
					real=$${real/"$$(pwd)/"/};				\
					sed -i "s^$$word^$$real $${real/%.h/.o}^g" $(1);	\
				elif [ -f "$${word/%.h/.cpp}" ]; then 				\
					real=$$(readlink -m $$word);				\
					real=$${real/"$$(pwd)/"/};				\
					sed -i "s^$$word^$$real $${real/%.h/.o}^g" $(1);	\
				fi;								\
			elif [[ $$word == *".hpp" && $$word != "$*.hpp" ]]; then		\
				if [ -f "$${word/%.hpp/.cpp}" ]; then				\
					real=$$(readlink -m $$word);				\
					real=$${real/"$$(pwd)/"/};				\
					sed -i "s^$$word^$$real $${real/%.hpp/.o}^g" $(1);	\
				fi;								\
			elif [[ $$word == *".hs" && $$word != "$*.hs" ]]; then			\
				if [ -f "$${word/%.hs/.s}" ]; then				\
					real=$$(readlink -m $$word);				\
					real=$${real/"$$(pwd)/"/};				\
					sed -i "s^$$word^$$real $${real/%.hs/.o}^g" $(1);	\
				fi;								\
			fi;									\
		done;										\
	done < $(1);
endef

#	This function records all of the object file dependencies for a particular object file (referenced by $1).  The function defines a
#	recursive bash function, which takes the current place in the tree as $1, and the original target as $2.  The inner function recurses
#	through the tree (depth-first) and copies all the object dependencies into a single output list.  Finally, the list is sorted to remove
#	any duplicate elements.  This flattens the dependency tree for the target object file.
define detect_link_dependencies
	function recurse_detect_link_dependencies()								\
	{													\
		find . -wholename "./$${1}.d*" |								\
		while read -a file; do										\
			while read -a line; do									\
				for word in $${line[@]}; do							\
					if [[ $${word} != *: ]]; then						\
						if [[ $${word} == *.o ]]; then					\
							if [ -a "`grep $${word} < $${2}.ld`" ]; then		\
								continue;					\
							fi;							\
							echo "$${word}" >> "$${2}.ld";				\
							recurse_detect_link_dependencies $${word/%.o/} $${2};	\
						fi;								\
					fi;									\
				done;										\
			done < $${file};									\
		done;												\
	};													\
	echo "$(1).o" > $(1).ld;										\
	recurse_detect_link_dependencies $(1) $(1);								\
	mv $(1).ld $(1).ld.tmp;											\
	sort -u $(1).ld.tmp > $(1).ld;										\
	rm $(1).ld.tmp
endef

#	This function finds all of the library files in the source tree, and adds them to a library dependency file.  Simply adding all the
#	files which match the appropriate naming scheme is sufficient; if any libraries are unused, then the linker will discard those objects
#	anyway.  Whilst trivial, we do this as a separate function in case we decide on some more complex behaviour later on.
define detect_libraries
	find . -name "lib*.a" > $(1).lld
endef

# PSEUDO-TARGETS

# All the pseudo-targets are phony: they don't correspond with real files.
.PHONY: all main

all: main

main: $(EXECUTABLE)

# TARGETS.

#	EXECUTABLE FILES.

%: %.d
	@echo -e "$(BOLD_WHITE)******** Linking $@ from Object Files. ********$(NO_COLOUR)"
	$(LD) -o $@ $(shell cat $@.ld) $(shell cat $@.lld) $(LFLAGS)

#	OBJECT FILES.

# Object from C.
%.o : %.c %.dc
	@echo -e "$(BOLD_WHITE)******** Compiling $@. ********$(NO_COLOUR)"
	$(CC) $(CFLAGS) -c $< -o $@

# Object from C++.
%.o : %.cpp %.dcpp
	@echo -e "$(BOLD_WHITE)******** Compiling $@. ********$(NO_COLOUR)"
	$(PC) $(PFLAGS) -c $< -o $@

# Object from assembly.
%.o : %.s %.ds
	@echo -e "$(BOLD_WHITE)******** Compiling $@. ********$(NO_COLOUR)"
	$(AS) $(AFLAGS) $< -o $@

#	ASSEMBLY FILES.

# Assembly from C.
%.s: %.c %.dc
	@echo -e "$(BOLD_WHITE)******** Assembling $@. ********$(NO_COLOUR)"
	$(CC) $(CFLAGS) -s $< -o $@

# Assembly from CPP.
%.s: %.cpp %.dcpp
	@echo -e "$(BOLD_WHITE)******** Assembling $@. ********$(NO_COLOUR)"
	$(CC) $(PFLAGS) -s $< -o $@

# DEPENDENCY TARGETS.

# Header file dependencies are calculated directly by the compiler, they are easy.  Object file dependencies are more complicated; they are 
# calculated by a separate function.

# Dependency from C.
%.dc: %.c
	@echo -e "$(BOLD_WHITE)******** Calculating dependencies for $*. ********$(NO_COLOUR)"
	@${CC} ${CFLAGS} -M $^ > $@
	@sed "s^.*:^$*.o:^g" -i $@
	@$(call detect_source_dependencies,$@)
	@cat $@ | head -n $(DEPENDENCY_LINES_TO_TRUNCATE)
	@if [ "`cat $@ | wc -l`" -gt "$(DEPENDENCY_LINES_TO_TRUNCATE)" ]; then echo "Listing truncated.  Complete dependency file $@ is `cat $@ | wc -l` lines long."; fi
	@if [ "`cat $@ | wc -l`" -lt "1" ]; then echo "File has no dependencies."; fi

# Dependency from C++.
%.dcpp: %.cpp
	@echo -e "$(BOLD_WHITE)******** Calculating dependencies for $*. ********$(NO_COLOUR)"
	@${PC} ${PFLAGS} -M $^ > $@
	@sed "s^.*:^$*.o:^g" -i $@
	@$(call detect_source_dependencies,$@)
	@cat $@ | head -n $(DEPENDENCY_LINES_TO_TRUNCATE)
	@if [ "`cat $@ | wc -l`" -gt "$(DEPENDENCY_LINES_TO_TRUNCATE)" ]; then echo "Listing truncated.  Complete dependency file $@ is `cat $@ | wc -l` lines long."; fi
	@if [ "`cat $@ | wc -l`" -lt "1" ]; then echo "File has no dependencies."; fi

# Dependency from assembly.
%.ds: %.s
	@echo -e "$(BOLD_WHITE)******** Calculating dependencies for $*. ********$(NO_COLOUR)"
	@${PC} ${PFLAGS} -M $^ > $@
	@sed "s^.*:^$*.o:^g" -i $@
	@$(call detect_source_dependencies,$@)
	@cat $@ | head -n $(DEPENDENCY_LINES_TO_TRUNCATE)
	@if [ "`cat $@ | wc -l`" -gt "$(DEPENDENCY_LINES_TO_TRUNCATE)" ]; then echo "Listing truncated.  Complete dependency file $@ is `cat $@ | wc -l` lines long."; fi
	@if [ "`cat $@ | wc -l`" -lt "1" ]; then echo "File has no dependencies."; fi

# The dependencies for the target output file are created by assuming that the target output file requires some object file which carries the same
# name as the executable being compiled.  It's assumed that from there, all other dependencies can be discovered from the include chain (this now
# includes assembler files, which will need header files so they are discovered).

# Dependencies of executable.
${EXECUTABLE}.d:
	@echo -e "$(BOLD_WHITE)******** Calculating executable dependencies. ********$(NO_COLOUR)"
	@# Work out what the main file is going to be, so we can build the output file.
	@echo -e "Assuming executable ${EXECUTABLE} will depend upon ${EXECUTABLE}.o"
	@echo -e "${EXECUTABLE}: $(@:.d=.ld) $(@:.d=.lld)\n" >> ${EXECUTABLE}.d

# Linking dependencies are calculated by a separate function.  These are not proper make-syntax dependencies, these are simply a list of those
# object files which need to be included for linking a particular executable.  This allows linking only those object files which are required.

# Linker dependency from source dependencies.
%.ld: %.o $(LOOSE_OBJECTS)
	@echo -e "$(BOLD_WHITE)******** Calculating linking dependencies for $*. ********$(NO_COLOUR)"
	@$(call detect_link_dependencies,$*)
	@echo $(LOOSE_OBJECTS) >> $@
	@sed -i "s^ ^\n^g; /^$$/d" $@
	@cat $@ | head -n $(DEPENDENCY_LINES_TO_TRUNCATE)
	@if [ "`cat $@ | wc -l`" -gt "$(DEPENDENCY_LINES_TO_TRUNCATE)" ]; then echo "Listing truncated.  Complete linker dependency file $@ is `cat $@ | wc -l` lines long."; fi
	@if [ "`cat $@ | wc -l`" -lt "1" ]; then echo "File has no linker dependencies (this seems unlikely, and probably indicates something is about to go wrong)."; fi

# Library dependencies are easy enough to calculate; since unused objects are discarded by the linker, we can simply include all the library (archive)
# files we find, and let the linker sort out which are actually needed.

# Linker library dependency from nothing.
%.lld: %.o
	@echo -e "${BOLD_WHITE}******** Searching for library files to include. ********$(NO_COLOUR)"
	@$(call detect_libraries,$*)
	@cat $@ | head -n $(DEPENDENCY_LINES_TO_TRUNCATE)
	@if [ "`cat $@ | wc -l`" -gt "$(DEPENDENCY_LINES_TO_TRUNCATE)" ]; then echo "Listing truncated.  Complete library dependency file $@ is `cat $@ | wc -l` lines long."; fi
	@if [ "`cat $@ | wc -l`" -lt "1" ]; then echo "File has no library dependencies."; fi

# IMPORT EXTERNAL DEPENDENCIES.

# Dependencies are calculated for all the source files, even if they might not be needed, because there isn't an option to go back and include
# additional rules later, so we have to include all the rules we might possibly need right from the start.

# Include dependencies for C files.
-include ${patsubst %.c, %.dc, ${shell find . -name "*.c"}}

# Include dependencies for C++ files.
-include ${patsubst %.cpp, %.dcpp, ${shell find . -name "*.cpp"}}

# Include dependencies for assembly files.
-include ${patsubst %.s, %.ds, ${shell find . -name "*.s"}}

# Dependencies also need to be calculated for the executable as a whole, so that we actually have some rules which create us the desired output
# file, using the appropriate source files.

# Include dependencies for executable main.
-include ${EXECUTABLE}.d



