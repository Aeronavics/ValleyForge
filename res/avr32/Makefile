#	Copyright (C) 2011  Unison Networks Ltd
#
#	This program is free software: you can redistribute it and/or modify
#	it under the terms of the GNU General Public License as published by
#	the Free Software Foundation, either version 3 of the License, or
#	(at your option) any later version.
#
#	This program is distributed in the hope that it will be useful,
#	but WITHOUT ANY WARRANTY; without even the implied warranty of
#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#	GNU General Public License for more details.
#
#	You should have received a copy of the GNU General Public License
#	along with this program.  If not, see <http://www.gnu.org/licenses/>.

#
# GENERIC AVR MAKEFILE WITH DEPENDANCY CALCULATION.
#
#	Author:		Edwin Hayes
#
#	Created:	9th Jan 2013
#

# VARIABLES.

# Make Configuration Details.
SHELL=/bin/bash # Need to use bash, since we use some non-posix features.

# Component & Filename Details.
COMPONENT=BUILD_INSERTS_COMPONENT_HERE
EXECUTABLE=BUILD_INSERTS_EXECUTABLE_HERE
OUTFILE=${EXECUTABLE}.elf # The output file which generally needs to be created.

# Target Details.
MCU=BUILD_INSERTS_MCU_CODE_HERE # The name/type of the target controller (as used by the compiler).
HEXFORMAT=ihex # The hex file format to use.

# Executables.
CC=BUILD_INSERTS_C_COMPILER_HERE # The C compiler to use.
PC=BUILD_INSERTS_P_COMPILER_HERE # The C++ compiler to use.
AS=BUILD_INSERTS_ASSEMBLER_HERE # The assembler to use.
LD=${CC} # The linker to use.
OBJDUMP=BUILD_INSERTS_OBJDUMP_HERE # The object-dump (binary manipulator) to use.
OBJCOPY=BUILD_INSERTS_OBJCOPY_HERE # The object-copy (binary manipulator) to use.
SIZE=BUILD_INSERTS_SIZE_HERE # The size utility (binary inspector) to use.

# Flags.
OPTLEVEL=s # Optimization level to use: s (for size), 1, 2, 3 (for performance) or 0 (none).
CFLAGS= -I . -g -O$(OPTLEVEL) -Wall -ffunction-sections -fpack-struct -fshort-enums -funsigned-bitfields -funsigned-char -fno-exceptions -mpart=$(MCU) BUILD_INSERTS_CFLAGS_HERE # The C compiler flags to apply.
PFLAGS= ${CFLAGS} BUILD_INSERTS_PFLAGS_HERE # The C++ compiler flags to apply.
AFLAGS=	-I. -mpart=$(MCU) -x assembler-with-cpp -Wall -gstabs BUILD_INSERTS_AFLAGS_HERE # The assember flags to apply.
LFLAGS= -g -Wl,--gc-sections -mpart=$(MCU) BUILD_INSERTS_LFLAGS_HERE # The linker flags to apply.

# FUNCTIONS.

#	This function parses a dependency file (referenced by $1) which will contain header file references (generated by the compiler's '-M' option) and tries to add
#	required sources file dependencies.  In this implementation, we assume that if a required header file has a matching source file in the same folder, then that 
#	will probably be an object dependency (and hence the source should be compiled).
define detect_source_dependencies
	while read -a line; do 									\
		for word in "$${line[@]}"; do 							\
			if [[ $$word == *".h" && $$word != "$*.h" ]]; then			\
				if [ -f "$${word/%.h/.c}" ]; then 				\
					sed -i "s^$$word^$$word $${word/%.h/.o}^g" $(1);	\
				fi;								\
			fi;									\
		done;										\
	done < $(1);										\
	while read -a line; do									\
		for word in "$${line[@]}"; do							\
			if [[ $$word == *".hpp" && $$word != "$*.hpp" ]]; then			\
				if [ -f "$${word/%.hpp/.cpp}" ]; then				\
					sed -i "s^$$word^$$word $${word/%.hpp/.o}^g" $(1);	\
				fi;								\
			fi;									\
		done;										\
	done < $(1);										\
	while read -a line; do									\
		for word in "$${line[@]}"; do							\
			if [[ $$word == *".hs" && $$word != "$*.hs" ]]; then			\
				if [ -f "$${word/%.hs/.s}" ]; then				\
					sed -i "s^$$word^$$word $${word/%.hs/.o}^g" $(1);	\
				fi;								\
			fi;									\
		done;										\
	done < $(1)
endef

# PSEUDO-TARGETS

# All the pseudo-targets are phony: they don't correspond with real files.
.PHONY: all main stats

all: main

main: ${OUTFILE}

stats: ${MAIN}
	${OBJDUMP} -h ${OUTFILE}
	${SIZE} ${OUTFILE}

# TARGETS.

#	OUTPUT FILES.

%.elf: %.o
	@echo "******** Linking $@ from Object Files. ********"
	$(LD) $(LFLAGS) -o $@ $(shell find . -name "*.o")

#	BINARY FILES.

# Hex files from elf.
.out.hex:
	$(OBJCOPY) -j .text -j .data -O $(HEXFORMAT) $< $@
.out.ee.hex:
	$(OBJCOPY) -j .eeprom --change-section-lma .eeprom=0 -O $(HEXFORMAT) $< $@

#	OBJECT FILES.

# Object from C.
%.o : %.c
	@echo "******** Compiling $@. ********"
	$(CC) $(CFLAGS) -c $< -o $@

# Object from C++.
%.o : %.cpp
	@echo "******** Compiling $@. ********"
	$(PC) $(PFLAGS) -c $< -o $@

# Object from assembly.
%.o : %.s
	@echo "******** Compiling $@. ********"
	$(AS) $(AFLAGS) $< -o $@

#	ASSEMBLY FILES.

# Assembly from C.
%.s: %.c
	@echo "******** Assembling $@. ********"
	$(CC) $(CFLAGS) -s $< -o $@

# Assembly from CPP.
%.s: %.cpp
	@echo "******** Assembling $@. ********"
	$(CC) $(CFLAGS) -s $< -o $@

# DEPENDENCY TARGETS.

# Header file dependencies are calculated directly by the compiler, they are easy.  Object file dependencies are more complicated; they are calculated by a separate function.

# Dependency from C.
%.dc: %.c
	@echo "******** Calculating dependencies for $*. ********"
	${CC} ${CFLAGS} -MM $^ > $@
	@$(call detect_source_dependencies,$@)
	@cat $@

# Dependency from C++.
%.dcpp: %.cpp
	@echo "******** Calculating dependencies for $*. ********"
	${PC} ${PFLAGS} -MM $^ > $@
	@$(call detect_source_dependencies,$@)
	@cat $@

# Dependency from assembly.
%.ds: %.s
	@echo "******** Calculating dependencies for $*. ********"
	${PC} ${PFLAGS} -MM $^ > $@
	@$(call detect_source_dependencies,$@)
	@cat $@

# The dependencies for the target output file are created by assuming that the target output file requires some object file which carries the same
# name as the executable being compiled.  It's assumed that from there, all other dependencies can be discovered from the include chain (this now
# includes assembler files, which will need header files so they are discovered).

# Dependencies of executable.
${EXECUTABLE}.d:
	@echo "******** Calculating executable dependencies. ********"
	@# Work out what the main file is going to be, so we can build the output file.
	@echo -e "${OUTFILE}: ${EXECUTABLE}.o\n" >> ${EXECUTABLE}.d

# IMPORT EXTERNAL DEPENDENCIES.

# Dependencies are calculated for all the source files, even if they might not be needed, because there isn't an option to go back and include
# additional rules later, so we have to include all the rules we might possibly need right from the start.

# Include dependencies for C files.
-include ${patsubst %.c, %.dc, ${wildcard *.c}}
-include ${patsubst %.c, %.dc, ${wildcard **/*.c}}

# Include dependencies for C++ files.
-include ${patsubst %.cpp, %.dcpp, ${wildcard *.cpp}}
-include ${patsubst %.cpp, %.dcpp, ${wildcard **/*.cpp}}

# Include dependencies for assembly files.
-include ${patsubst %.s, %.ds, ${wildcard *.s}}
-include ${patsubst %.s, %.ds, ${wildcard **/*.s}}

# Dependencies also need to be calculated for the executable as a whole, so that we actually have some rules which create us the desired output
# file, using the appropriate source files.

# Include dependencies for executable main.
-include ${EXECUTABLE}.d


