<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
	   <head>
      <link rel="stylesheet" type="text/css" href="../../AVR32_ns.css">
   </head>
	 <body>
<div id="wrapper">
<p align="left" class="whs2"><a href="../../../readme.html"<font color="red"></font>Back to main page</a></p>
<h1 align="center" class="whs1">AVR Software Framework: Embedded Development Quick Start<br>
</h1>
<p align="center" class="whs2">Copyright &copy; 2007 Atmel Corporation</p>
</li>
</ul>

<h2>Introduction</h2>
<p>The intention of this guide is to help users <b>getting started with AVR UC3
embedded development</b>. It is a quick reference on how to create an application for the AVR {
<!-- UC3A_START -->
  UC3A,
<!-- UC3A_END -->
<!-- UC3B_START -->
  UC3B,
<!-- UC3B_END -->
<!-- UC3A3_START -->
  UC3A3,
<!-- UC3A3_END -->
<!-- UC3L_START -->
  UC3L
<!-- UC3L_END -->
} with the <b>GNU Toolchain</b> and how to run and debug it.</a>.
</p><p><b><i>NOTE:</b> Make sure to install all tools before using this guide. </p>
Atmel recommends that you upgrade your software by visiting <a href="http://www.atmel.com/avr"> http://www.atmel.com/avr </a> and download the latest versions of the ASF and the GNU Toolchain.
</i></p>
<p>&nbsp;</p>
Then start Cygwin or a standard Linux terminal or a DOS command line, to execute
the commands described in each step. Also note that this guide requires a JTAGmkII emulator.</i></p>

 <p>&nbsp;</p>
<h3>Hardware Requirements</h3>
This quick guide has been designed for 

<p>

<b>EVK1100 evaluation kit and AT32UC3A0512.</b>
 <li>Connect the provided power cable (with 5.5/2.1mm DC plug) to a power supply (8 to 20V)or plug a USB cable.</li>
 <li>Set the board’s power switch according to your settings ("EXT" for external supply, "USB" for USB cable supply) .</li>

<b>EVK1101 evaluation kit and AT32UC3B0256.</b>
 <li>Connect the provided power cable (with 5.5/2.1mm DC plug) to a power supply (8 to 20V)or plug a USB cable.</li>
 <li>Set the board’s power switch according to your settings ("EXT" for external supply, "USB" for USB cable supply) .</li>

<b>EVK1104 evaluation kit and AT32UC3A3256.</b>
 <li>Connect a PC USB cable to the USB VPC plug (the USB plug on the right)of the EVK1104.</li>

<b>STK600+RCUC3L0 or UC3L-EK evaluation kit and AT32UC3L064.</b>
<li>Connect the JTAGICE mkII emulator to the kit's JTAG connector and to your PC.</p></li>

<b>UC3C-EK and AT32UC3C0512C</b>
 <li>Connect a PC USB cable to the USB VPC plug (the USB plug on the right)of the UC3C-EK.</li>

<p>Connect the JTAGICE mkII emulator to the kit's JTAG connector and to your PC. 
<i><p>Make sure you have the latest tools installed so the emulator will be well recognized by your operating system.</i></p></li>

 <p>&nbsp;</p>
  <p>&nbsp;</p>
<h2>Quick Start with the GNU Toolchain</h2>
<p>&nbsp;</p> 
<h3>Step 1: Prepare a test application</h3>

</p><p>Each driver folder of the ASF (/drivers directory) includes code to handle the peripheral,
example code to use the driver, building scripts (Makefile) and
documentation (readme.html). This quick step guide will use one of the GPIO example.
</p><p>Install the ASF. <i>You may also want to check
 the <a href="../../installation.html"> installation page</a> for details regarding the installation of the ASF.</i>
</p>
<p>&nbsp;</p>
<h3>Step 2: Compiling</h3>
<p>GCC, the GNU Compiler Collection is used at the compilation stage. The avr32 version
of GCC is used by calling avr32-gcc. The compiler supports c-code compilation, assembly
and linking.
</p><p>Compile the GPIO software driver peripheral bus example by invoking <code>'make'</code> from the copied source
location. Eg for AT32UC3A0512 running on EVK1100 board: 
</p>

<pre>cd /drivers/gpio/peripheral_bus_example/at32uc3a0512_evk1100/gcc
make
</pre>

<p>This will run the GNU Makefile which calls avr32-gcc and produces the exe file
<code>uc3a0512-gpio_peripheral_bus_example.elf</code>.
</p>

<p>&nbsp;</p> 
<h3>Step 3: Program uploading</h3>
<p>The application <code>avr32program</code> can be used to program the device. 
</p><p>To program-only the device with the GPIO example, use the following command line (eg for AT32UC3A0512):
</p>

<pre>avr32program program -finternal@0x80000000,512Kb -e -v uc3a0512-gpio_peripheral_bus_example.elf
</pre>

<ul><li><code>'-finternal@0x80000000,512Kb'</code> tells the programmer that the
internal flash starts at address 0x80000000 and that its size is 512Kb.
</li>
<li><code>'-e'</code> is used to erase the flash before programming it.
</li><li><code>'-v'</code> is used to verify the flash programming. 
</li></ul>
<p>For more information about avr32program usage and parameters, use the builtin help command:
<pre>avr32program -h
</pre></p>
<p>For example, to program, reset and run the target for AT32UC3A0512:
</p>
<pre>avr32program program -finternal@0x80000000,512Kb -e -v -R -r uc3a0512-gpio_peripheral_bus_example.elf
</pre>
<ul><li><code>'-R'</code> is used to reset the MCU,
</li><li><code>'-r'</code> is used to run the program.
</li></ul>
<p><br>

The Makefile (eg drivers/gpio/peripheral_bus_example/at32uc3a0512/gcc/makefile) also comes with pre-built Make targets:
</p>
<li> [all]:                       Default goal: build the project.
  </li><li> clean:                  Clean up the project.
  </li><li> rebuild:                Rebuild the project.
  </li><li> ccversion:              Display CC version information.
  </li><li> cppfiles  file.i:       Generate preprocessed files from C source files.
  </li><li> asfiles   file.x:       Generate preprocessed assembler files from C and assembler source files.
  </li><li> objfiles  file.o:       Generate object files from C and assembler source files.
  </li><li> a         file.a:       (Archive) Create an archive output file from object files.
  </li><li> elf       file.elf:     (Link) Create ELF output file from object files.
  </li><li> lss       file.lss:     Create extended listing from target output file.
  </li><li> sym       file.sym:     Create symbol table from target output file.
  </li><li> hex       file.hex:     Create Intel HEX image from ELF output file.
  </li><li> bin       file.bin:     Create binary image from ELF output file.
  </li><li> sizes:                  Display target size information.
  </li><li> isp:                    Use ISP instead of JTAGICE mkII when programming.
  </li><li> cpuinfo:                Get CPU information.
  </li><li> halt:                   Stop CPU execution.
  </li><li> chiperase:              Perform a JTAG Chip Erase command.
  </li><li> erase:                  Perform a flash chip erase.
  </li><li> program:                Program MCU memory from ELF output file.
  </li><li> secureflash:            Protect chip by setting security bit.
  </li><li> reset:                  Reset MCU.
  </li><li> debug:                  Open a debug connection with the MCU.
  </li><li> run:                    Start CPU execution.
  </li><li> readregs:               Read CPU registers.
  </li><li> doc:                    Build the documentation.
  </li><li> cleandoc:               Clean up the documentation.
  </li><li> rebuilddoc:             Rebuild the documentation.
  </li><li> verbose:                Display main executed commands.
  </li>
<p>&nbsp;</p>

<p>So for example, to program the target, reset the target and then run the program, you could also type:
</p>
<pre> make program reset run
</pre>

<p>&nbsp;</p>
<h3>Step 4: Debugging</h3>
<p>The application can be debugged on target using the GNU Project Debugger(GDB)
and a JTAGICE mkII. This requires that a GDB proxy server is used. The proxy will
translate standard GDB requests such as read memory, read registers and set
breakpoints into JTAGICE mkII operations. </p>
<p>GDB is an open standard and any debugger supporting GDB may be connected to
the GDB proxy server using socket communication. </p>
<i>GBD Proxy Interface </i>
</p><p><a href="./embedded_development_quick_start_files/Avr32_embedded_debugging.png" class="image" title="Image:avr32_embedded_debugging.png"><img src="embedded_development_quick_start_files/Avr32_embedded_debugging.png" alt="Image:avr32_embedded_debugging.png" height="102" width="527"></a>
</p><p><br>
</p>

<p>&nbsp;</p>
<h4>Step 4.1:  Start GDB proxy server</h4>
<p>The AVR32 GDB proxy server must be started before using a
GDB-client. Use the following command to start avr32gdbproxy and
connect it to a host called 'extended-remote' with port number '4242', eg. on UC3A0512:
</p>
<pre>avr32gdbproxy -finternal@0x80000000,512Kb &
</pre>

<p>The -f parameter tells the GDB proxy server where the flash memory is located. For information about additional parameters use:
</p>
<pre>avr32gdbproxy -h
</pre>
<p><br>
</p>


<h4>Step 4.2:  Start GDB Client</h4>
<p>Once the GDB proxy server is up an running, the user can communicate
with it using any debugger with GDB support. This is done by using the
same host name and port number as when avr32gdbproxy was invoked.
avr32-gdb is a command line based GDB-client, and it can be used to
demonstrate how the GPIO example can be debugged. </p>
<p>Start a new terminal and go to your source directory, eg for the AT32UC3A0512 and EVK1100:</p>
<pre>cd /drivers/gpio/peripheral_bus_example/at32uc3a0512_evk1100/gcc
</pre>

<p>Start the GDB-client with the following command:
</p>
<pre>avr32-gdb
</pre>
<p>Remember to keep the avr32gdbproxy running during the entire debug
session. If a command line based GDB-client like avr32-gdb is used, it
must be called from a new terminal. If Cygwin is used, one can easily
do this by starting Cygwin one more time, so that there are two Cygwin
windows: one with the GDB proxy and one with the GDB-client.
</p><p>Once the GDB-client is started, use the following GDB commands to initiate a debug session:
</p>
<pre>(gdb) target extended-remote:4711
</pre>
<p>This connects the gdb-client to the avr32gdbproxy server (assuming host name 'extended-remote' and port number '4242').
Then load the symbol table from executable file. Eg. for UC3A GPIO example:
</p>

<pre>(gdb) sym uc3a0512-gpio_peripheral_bus_example.elf
</pre>

<p>To start executing the test application:
</p>
<pre>(gdb) cont
</pre>

Get more help on GDB here: http://sources.redhat.com/gdb/current/onlinedocs/gdb_toc.html#SEC_Contents

<p>&nbsp;</p>

<h5>Useful GBD commands</h4>
This section gives a brief introduction to the command based GDB-client avr32-gdb and its command set.</p>
Get help
<pre>(gdb) help </pre>
Set the program counter to the start address

<pre>(gdb) set $pc = _start</pre>
Start execution on target

<pre>(gdb) cont</pre>

Stop execution:

Use standard keys for interruption: ctrl-c

Getting general help on a specific topic:

<pre>(gdb) help 'topic'</pre>

It is also useful to know that by pressing the 'tab' key, for instance after having typet 'help', GDB will display all possible symbols that will be accepted. The 'tab' key works both alone, and after a keyword (such as 'help').

End GDB session and quit:

<pre>(gdb) quit</pre>

Getting an overview:

<pre>(gdb) where full</pre>

Display source code:

<pre>(gdb) list</pre>

Display disassembly:

<pre>(gdb) disassemble</pre>

Display variables:

<pre>(gdb) print 'symbol name'</pre>

Setting a variable:

<pre>(gdb) set 'symbol name' = 'value'</pre>

Single step:

<pre>(gdb) s</pre>

Instruction step:

<pre>(gdb) si</pre>

Next:

<pre>(gdb) n</pre>

Setting a breakpoint:

<pre>(gdb) break 'line number', 'function name' or 'address'</pre>

Clearing a breakpoint:

<pre>(gdb) clear 'line number' , 'function name', 'address' or breakpoint number</pre>

Setting a data breakpoint (at address 0xffff):

<pre>(gdb) watch *0x0000ffff</pre>

Clearing a data breakpoint:

<pre>(gdb) delete 'data breakpoint number'</pre>

Show general registers

<pre>(gdb) regs</pre>

Set general register:

<pre>(gdb) set $r1=0x0</pre>

Show system registers

<pre>(gdb) show sysreg 4</pre>

Set system register:

<pre>(gdb) set sysreg 4=0x0</pre>



<hr align="center" width="50%" class="whs4">


</div>
   </body>
</html>
 
